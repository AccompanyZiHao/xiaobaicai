{"meta":{"title":"小白菜的博客","subtitle":null,"description":null,"author":"Zihao","url":"https://staraccompany.gitee.io/blog","root":"./"},"pages":[{"title":"about","date":"2019-08-23T08:21:33.000Z","updated":"2019-08-23T08:28:32.321Z","comments":true,"path":"about/index.html","permalink":"https://staraccompany.gitee.io/blog/about/index.html","excerpt":"","text":"。。。 emmm 还在思考中的小白菜 (#^.^#)"}],"posts":[{"title":"js 工具函数","slug":"js-工具函数","date":"2020-08-22T02:23:23.000Z","updated":"2020-08-22T02:28:04.379Z","comments":true,"path":"2020/08/22/js-工具函数/","link":"","permalink":"https://staraccompany.gitee.io/blog/2020/08/22/js-工具函数/","excerpt":"","text":"判断日期是否是同一天12345isSameDay(timeA, timeB) &#123; let dateStart = new Date(timeA); let dateEnd = new Date(timeB); return (dateStart.setHours(0, 0, 0, 0) == dateEnd.setHours(0, 0, 0, 0));&#125;","categories":[],"tags":[]},{"title":"几种快速生成有序整数数组方法参","slug":"几种快速生成有序整数数组方法参","date":"2020-08-21T10:08:45.000Z","updated":"2020-08-22T02:19:09.661Z","comments":true,"path":"2020/08/21/几种快速生成有序整数数组方法参/","link":"","permalink":"https://staraccompany.gitee.io/blog/2020/08/21/几种快速生成有序整数数组方法参/","excerpt":"","text":"1. for 循环的方式123var arr = []; for (let i = 0; i &lt; 40; i++)arr.push(i);// 或var arr = []; for (let i = 0; i &lt; 40; i++)arr[i] = i; 2. 使用 Array.fromArray.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。 1const arr = Array.from(&#123; length: 20 &#125;, (v, i) =&gt; i); 语法1Array.from(arrayLike[, mapFn[, thisArg]]) 参数arrayLike想要转换成数组的伪数组对象或可迭代对象。 mapFn （可选）如果指定了该参数，新数组中的每个元素会执行该回调函数。 thisArg (可选)可选参数，执行回调函数 mapFn 时 this 对象。 返回值一个新的数组实例。 3. 使用 Array.applyapply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。 1Array.apply(null, &#123; length: 20 &#125;).map((v, i) =&gt; i); 4. 使用 Array.prototype.fill()fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 1const arr = Array(40).fill().map((v, i) =&gt; i);","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"}]},{"title":"javaScript 内存空间详解","slug":"javaScript-内存空间详解","date":"2019-09-11T06:27:18.000Z","updated":"2019-09-11T06:51:25.338Z","comments":true,"path":"2019/09/11/javaScript-内存空间详解/","link":"","permalink":"https://staraccompany.gitee.io/blog/2019/09/11/javaScript-内存空间详解/","excerpt":"","text":"原文链接：https://github.com/yygmind/blog/issues/14 在学习内存空间之前先了解一下栈、堆、队列 栈： 栈的结构就是后进先出（LIFO） 堆数据结构：堆数据结构是一种树状结构。它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书取出来。JSON格式的数据中，我们存储的key-value可以是无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。 队列：是一种先进先出（FIFO）的数据结构，这是事件循环（Event Loop）的基础结构 变量的存放首先我们应该知道内存中有栈和堆，那么变量应该存放在哪里呢，堆？栈？ 1 基本类型 –&gt; 保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。基本类型一共有6种：Undefined、Null、Boolean、Number 、String和Symbol 2 引用类型 –&gt; 保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，但内存地址大小的固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。 在计算机的数据结构中，栈比堆的运算速度快，Object是一个复杂的结构且可以扩展：数组可扩充，对象可添加属性，都可以增删改查。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。所以查找引用类型值的时候先去栈查找再去堆查找 几个问题 问题1： 1234var a = 20;var b = a;b = 30;console.log(a) 问题2： 1234var a = &#123; name: &apos;前端开发&apos; &#125;var b = a;b.name = &apos;进阶&apos;;console.log(b.name) 问题3： 1234var a = &#123; name: &apos;前端开发&apos; &#125;var b = a;a = null;console.log(b) 现在来解答一下，三个问题的答案分别是20、‘进阶’、{ name: ‘前端开发’ } 1 对于问题1，a、b都是基本类型，它们的值是存储在栈中的，a、b分别有各自独立的栈空间，所以修改了b的值以后，a的值并不会发生变化。2 对于问题2，a、b都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改b.name的值后，相应的a.name也就发生了改变。3 对于问题3，首先要说明的是null是基本类型，a = null之后只是把a存储在栈内存中地址改变成了基本类型null，并不会影响堆内存中的对象，所以b的值不受影响。 内存空间管理JavaScript的内存生命周期是 1、分配你所需要的内存 2、使用分配到的内存（读、写） 3、不需要时将其释放、归还 JavaScript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，使用a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。 思考： 123456var a = &#123;n: 1&#125;;var b = a;a.x = a = &#123;n: 2&#125;;a.x // 这时 a.x 的值是多少b.x // 这时 b.x 的值是多少 这一行代码 a.x = a = {n: 2};. 操作符的优先级比赋值高。解构一下发生了什么： a.x = undefined a.x = { n: 2 } // 等同于 b.x = { n:2 } a = { n:2 } // a 的引用指向发生了变化123456789a.x = undefinedb.x = &#123;n:2&#125;a = &#123;n:2&#125;b = &#123; n:1, x:&#123; n:2 &#125;&#125; 如果还不理解的话可以看下面这条链接https://www.zhihu.com/question/41220520","categories":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"}]},{"title":"面向对象编程 && 函数式编程","slug":"面向对象编程-函数式编程","date":"2019-09-03T01:54:53.000Z","updated":"2019-09-03T04:08:31.818Z","comments":true,"path":"2019/09/03/面向对象编程-函数式编程/","link":"","permalink":"https://staraccompany.gitee.io/blog/2019/09/03/面向对象编程-函数式编程/","excerpt":"","text":"面向对象编程在面向对象编程中最常见的表现形式就是类，提供了面向对象的 3大特点和 5大原则，这东西网上特别多，我只做简单的罗列，下面我会对特点进行实现，我的理解: 原则是面向对象编程的规范，而特点是面向对象编程的实现，前提是你已经仔细理解过下面对核心概念。 三大特点 继承 多态 封装 五大原则 单一 【一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一项工作】 开放封闭 【对象或实体应该对扩展开放，对修改封闭。】 里氏替换 【即对父类的调用同样适用于子类】 依赖倒置 【高层次的模块不应该依赖于低层次的模块】 接口隔离 【不应强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法】 继承继承是面向对象一个特点，可以实现子类调用自己没有的属性方法【父类属性方法】 123456789101112131415161718192021222324252627282930313233343536373839/** ES6 **/class Parent &#123;&#125;class Child extends Parent &#123; constructor () &#123; super() &#125; &#125;/** ES5 **/function parent () &#123; this.run () &#123;&#125; &#125;parent.prototype.eat = function () &#123;&#125;function child () &#123;&#125;// 原型式继承child.prototype = parent.prototypechild.prototype.constructor = child// 原型链继承child.prototype = new parent()child.prototype.constructor = child// 构造器继承function boyChild (..arg) &#123; parent.apply(this, arg) &#125;// 组合继承function boyChild (..arg) &#123; parent.apply(this, arg) &#125;boyChild.prototype = new parent()child.prototype.constructor = child// 寄生组合继承function child (..arg) &#123; parent.apply(this, arg) &#125;// $&#123;1&#125;( function () &#123; function transmit () &#123;&#125;; transmit.prototype = parent.prototype child.prototype = new prototype() child.prototype.constructor = child &#125;)()// $&#123;2&#125;child.prototype = Object.create(parent.prototype) 总结: 继承的方式方法多种多样，不外乎，就是通过，某一种方式将不属于自己的属性方法可以调用，沿着原型的方式和拷贝赋值就可以总结出很多种不同的继承方式，每种方式的优缺点，多是考虑，继承的属性方法的完整性和对实例化对象的影响，如实例上方法和原型链上方法是否都可以调用有或者引用传递改变同一原型链问题。 12345678910111213141516/** 上面为对实例对继承，下面说一说对于接口对继承 **/// ES6 中并没有提供接口这个概念，但是 Typescript 中对于接口又很好对支持，typescript 是 javascript 对超集，对面向对象提供了非常好对支持// Typescript 【一时用一时爽，一直用一直爽】// 很推荐用这个，他能避免很多低级错误，提供类型检查，特别是写过 java 转前端的。interface parent &#123; run: () =&gt; void &#125;class child implements parent &#123; run () &#123;&#125; &#125;// 转码后var child = /** @class */ (function () &#123; function child() &#123; &#125; child.prototype.run = function () &#123; &#125;; return child;&#125;())","categories":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"}]},{"title":"vue 中 slot-scope 使用场景的理解","slug":"vue-中-slot-scope-使用场景的理解","date":"2019-09-02T06:58:52.000Z","updated":"2019-09-02T07:59:32.990Z","comments":true,"path":"2019/09/02/vue-中-slot-scope-使用场景的理解/","link":"","permalink":"https://staraccompany.gitee.io/blog/2019/09/02/vue-中-slot-scope-使用场景的理解/","excerpt":"","text":"原文链接： https://segmentfault.com/a/1190000015884505 Vue 的插槽分为3种 匿名插槽 具名插槽 作用域插槽 前两种很好理解，无论就是子组件里定义一个slot占位符，父组件调用时，在slot对应的位置填充模板就好了。 作用域插槽的慨念，文档却只有一句简单的描述 有的时候你希望提供的组件带有一个可从子组件获取数据的可复用的插槽。 网络上大多数文章，也是千篇一律的翻译这句话，可是仅凭这一句话，我想象不到slot-scope的使用场景。 前言介绍了写这篇文章的来由，接下来简述一下本文的脉络 首先，我会结合文档上todo-list的例子，来简单说明一下slot-scope的使用方式 其次，会使用但不理解什么时候用，就没有什么意义，所以本文第二部分，谈一下个人对于其使用场景的理解 最后，是我翻阅网络上关于slot-scope时，看到的一些我觉得不太恰当的案例 官方文档slot-scope的示例下面是2个父子的vue组件，先解释一下2个组件做了什么事情 父组件仅仅是调用了子组件 子组件内部实现了一个todolist列表 我建议从数据流动的角度，理解插槽作用域的使用方式，（先学会怎么用，暂时不用理解为什么要这么用,使用场景是第二部分） 父组件传递了todos数组给子组件 子组件通过props接受了数组数据，这里应该没有任何问题 子组件拿到数组后v-for渲染列表，并且通过 的方式，把数组内的每一个todo对象，传递给父组件 父组件通过slot-scope=”slotProps”的方式，接受todo对象，之后就可以通过slotProps.todo.xxx的方式来使用了 所以数据的流动经历了 父组件传递todos数组给子组件 子组件遍历todos数组，把里面的todo对象传递给父组件 好啦，这就是slot-scope的使用方法，就这么简单，完结撒花~ 我贴出全部代码，方便大家自己研究 父组件的源码，也就是调用者 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;todo-list :todos=&quot;todos&quot;&gt; &lt;template slot-scope=&quot;slotProps&quot;&gt; &lt;span v-if=&quot;slotProps.todo.isComplete&quot;&gt;✓&lt;/span&gt; &lt;span&gt;&#123;&#123;slotProps.todo.text&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/todo-list&gt;&lt;/template&gt;&lt;script&gt;import todoList from &apos;./todoList&apos;export default &#123; data () &#123; return &#123; todos: [ &#123; id: 0, text: &apos;ziwei0&apos;, isComplete: false &#125;, &#123; text: &apos;ziwei1&apos;, id: 1, isComplete: true &#125;, &#123; text: &apos;ziwei2&apos;, id: 2, isComplete: false &#125;, &#123; text: &apos;ziwei3&apos;, id: 3, isComplete: false &#125; ] &#125; &#125;, components: &#123; todoList &#125;,&#125;&lt;/script&gt; 子组件源码，也就是封装组件的人 123456789101112131415161718&lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt; &lt;slot :todo=&quot;todo&quot;&gt; &lt;/slot&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; todos: &#123; type: Array &#125; &#125;&#125;&lt;/script&gt; slot-scope的使用场景的个人理解想象一个场景： 当你要给同事封装一个列表组件，你就需要使用作用域插槽（注意是列表或者类似列表的组件） 你开发的这个列表组件要如何使用呢？ 一般来说作为列表组件的调用者，你的同事先做ajax请求，拿到一个这样的数组 12345678910111213141516171819202122todos: [ &#123; id: 0, text: &apos;ziwei0&apos;, isComplete: false &#125;, &#123; text: &apos;ziwei1&apos;, id: 1, isComplete: true &#125;, &#123; text: &apos;ziwei2&apos;, id: 2, isComplete: false &#125;, &#123; text: &apos;ziwei3&apos;, id: 3, isComplete: false &#125; ] 之后会把todso传递给列表组件吧，那么列表组件内部做什么事情呢？ 列表内部肯定会v-for去帮你的同事渲染这个数组嘛。 就类似element-ui里的table组件一样 问题的关键就在这里 列表组件的循环，是发生在组件内部的，所以通过 v-for=”todo in todos” ,列表组件很容易拿到每一项todo，但列表拿到数据没用呀，列表只是一个瓜皮，它又不懂业务逻辑 这个数据是你同事的业务数据，所以这个数据必须得交给组件的调用者，也就是把数据交给你的同事才对。 那么你怎样才能把每一项的todo数据给传递出去呢？ 你会发现没有办法！ 无论是用$emit、vuex还是localStorage，可以考虑一下，会发现没有合适的时机，能让你把todo传递出去 所以为了应对这个场景下，发明了作用域插槽，列表组件可以通过传递todo出去 你的同事可以通过 slot-scope=”slotsProps”拿到todo。 回答几个疑问，其实如果你看懂上面的问题，应该可以回答下面的问题。这也是我曾经的疑问 疑问1：一般不是我们传参数来调用组件吗？为什么组件还把数据传递回来？ 的确，调用ui组件时一般是我们传递配置参数给他们。 但是就像elemnt-ui的table组件，你把数组传递给table后，是不是有时候需要拿到某一行的row对象 并根据row对象里的字段，来判断一些内容的显示隐藏？ 因为循环的过程发生在table组件内部，所以table组件可以方便的获取到每一项数据，但是这些数据最终不是给组件的，而是我们自己要用的业务数据。所以也需要一个方式，让调用者能拿到自己想要的数据 疑问2： 既然子组件最终还要把我给他的数据，再返还给我，那我当初还干嘛给它，能不能就自己在父组件里玩？ 如果你不把数据给子组件当然可以。但是就等于抛弃掉了子组件的封装，只能你直接在父组件自己写一个列表 毕竟你不把数据给子组件，子组件还渲染个锤子？没有父子关系的话，也就不用什么插槽了。 但是咱不是为了封装后，可以复用嘛，总不能永远不用组件嘛 疑问3： 父组件需要子组件的数据？那不会有$emit和vuex嘛，为什么要有slot-scope？ $emit和vuex是数据传递的一种方法，但是你可以尝试用$emit和vuex把todo传递给父组件。 你会发现的确没有合适的钩子、时机来$emit数据 一些网上个人认为不太恰当的例子我认为几种说法是不太恰当的，也是给我造成一些困惑的 slot-scope是什么？就是把子组件的数据传递给父组件的一种方式这种说法，会让我觉得slot-scope跟emit和vuex是一类东西 在一些例子中，把数据定义在写死在列表组件中，展示如何把数据传递出去这些举例子的不恰当之处，我觉得是不应该把数据定义在子组件里。 因为真正的使用场景下，子组件的数据都是来自父组件的。作为组件内部应该保持纯净。 就像element-ui里的table组件，肯定不会定义一些数据在组件内部，然后传递给你。 table组件的数据都是来自调用者的，然后table会把每一行的row，在开发者需要时，传递出去。 这些例子虽然不是错误，但是我觉得反而不利于理解slot-scope","categories":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/tags/vue/"}]},{"title":" Array.from 的用法","slug":"Array-from-的用法","date":"2019-08-29T09:11:59.000Z","updated":"2019-08-29T11:01:55.211Z","comments":true,"path":"2019/08/29/Array-from-的用法/","link":"","permalink":"https://staraccompany.gitee.io/blog/2019/08/29/Array-from-的用法/","excerpt":"","text":"参考链接：https://dmitripavlutin.com/javascript-array-from-applications/ 任何一种编程语言都具有超出基本用法的功能，它得益于成功的设计和试图去解决广泛问题。JavaScript 中有一个这样的函数: Array.from：允许在 JavaScript 集合(如: 数组、类数组对象、或者是字符串、map 、set 等可迭代对象) 上进行有用的转换。 一. 介绍在开始之前，我们先回想一下 Array.from() 的作用。语法: 1Array.from(arrayLike[, mapFunction[, thisArg]]) arrayLike：必传参数，想要转换成数组的伪数组对象或可迭代对象。 mapFunction：可选参数，mapFunction(item，index){…} 是在集合中的每个项目上调用的函数。返回的值将插入到新集合中。 thisArg：可选参数，执行回调函数 mapFunction 时 this 对象。这个参数很少使用。 例如，让我们将类数组的每一项乘以2： 12const someNumbers = &#123; &apos;0&apos;: 10, &apos;1&apos;: 15, length: 2 &#125;;Array.from(someNumbers, value =&gt; value * 2); // =&gt; [20, 30] 二. 将类数组转换成数组Array.from() 第一个用途：将类数组对象转换成数组。 通常，你会碰到的类数组对象有：函数中的 arguments 关键字，或者是一个 DOM 集合。 在下面的示例中，让我们对函数的参数求和： 1234function sumArguments() &#123; return Array.from(arguments).reduce((sum, num) =&gt; sum + num);&#125;sumArguments(1, 2, 3); // =&gt; 6 此外，Array.from() 的第一个参数可以是任意一个可迭代对象，我们继续看一些例子: 1234567Array.from(&apos;Hey&apos;); // =&gt; [&apos;H&apos;, &apos;e&apos;, &apos;y&apos;]Array.from(new Set([&apos;one&apos;, &apos;two&apos;])); // =&gt; [&apos;one&apos;, &apos;two&apos;]const map = new Map();map.set(&apos;one&apos;, 1)map.set(&apos;two&apos;, 2);Array.from(map); // =&gt; [[&apos;one&apos;, 1], [&apos;two&apos;, 2]] 三. 克隆一个数组在 JavaScript 中有很多克隆数组的方法。正如你所想，Array.from() 可以很容易的实现数组的浅拷贝。 1234const numbers = [3, 6, 9];const numbersCopy = Array.from(numbers);numbers === numbersCopy; // =&gt; false Array.from(numbers) 创建了对 numbers 数组的浅拷贝，numbers === numbersCopy 的结果是 false，意味着虽然 numbers 和 numbersCopy 有着相同的项，但是它们是不同的数组对象。 是否可以使用 Array.from() 创建数组的克隆，包括所有嵌套的？挑战一下！ 123456789function recursiveClone(val) &#123; return Array.isArray(val) ? Array.from(val, recursiveClone) : val;&#125;const numbers = [[0, 1, 2], [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]];const numbersClone = recursiveClone(numbers);numbersClone; // =&gt; [[0, 1, 2], [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]]numbers[0] === numbersClone[0] // =&gt; false recursiveClone() 能够对数组的深拷贝，通过判断 数组的 item 是否是一个数组，如果是数组，就继续调用 recursiveClone() 来实现了对数组的深拷贝。 四. 使用值填充数组如果你需要使用相同的值来初始化数组，那么 Array.from() 将是不错的选择。 我们来定义一个函数，创建一个填充相同默认值的数组： 12345const length = 3;const init = 0;const result = Array.from(&#123; length &#125;, () =&gt; init);result; // =&gt; [0, 0, 0] result 是一个新的数组，它的长度为3，数组的每一项都是0。调用 Array.from() 方法，传入一个类数组对象 { length } 和 返回初始化值的 mapFunction 函数。 但是，有一个替代方法 array.fill() 可以实现同样的功能。 1fillArray2(0, 3); // =&gt; [0, 0, 0] 4.1 使用对象填充数组 当初始化数组的每个项都应该是一个新对象时，Array.from() 是一个更好的解决方案： 123456789const length = 3;const resultA = Array.from(&#123; length &#125;, () =&gt; (&#123;&#125;));const resultB = Array(length).fill(&#123;&#125;);resultA; // =&gt; [&#123;&#125;, &#123;&#125;, &#123;&#125;]resultB; // =&gt; [&#123;&#125;, &#123;&#125;, &#123;&#125;]resultA[0] === resultA[1]; // =&gt; falseresultB[0] === resultB[1]; // =&gt; true 由 Array.from 返回的 resultA 使用不同空对象实例进行初始化。之所以发生这种情况是因为每次调用时，mapFunction，即此处的 () =&gt; ({}) 都会返回一个新的对象。然后，fill() 方法创建的 resultB 使用相同的空对象实例进行初始化。不会跳过空项。 4.2 使用 array.map 怎么样？ 是不是可以使用 array.map() 方法来实现？我们来试一下: 12345const length = 3;const init = 0;const result = Array(length).map(() =&gt; init);result; // =&gt; [undefined, undefined, undefined] map() 方法似乎不正常，创建出来的数组不是预期的 [0, 0, 0]，而是一个有3个空项的数组。这是因为 Array(length) 创建了一个有3个空项的数组(也称为稀疏数组)，但是 map() 方法会跳过空项。 五. 生成数字范围你可以使用 Array.from() 生成值范围。例如，下面的 range 函数生成一个数组，从0开始到 end - 1。 12345function range(end) &#123; return Array.from(&#123; length: end &#125;, (_, index) =&gt; index);&#125;range(4); // =&gt; [0, 1, 2, 3] 在 range() 函数中，Array.from() 提供了类似数组的 {length：end} ，以及一个简单地返回当前索引的 map 函数 。这样你就可以生成值范围。 六. 数组去重由于 Array.from() 的入参是可迭代对象，因而我们可以利用其与 Set 结合来实现快速从数组中删除重复项。 12345function unique(array) &#123; return Array.from(new Set(array));&#125;unique([1, 1, 2, 3, 3]); // =&gt; [1, 2, 3] 首先，new Set(array) 创建了一个包含数组的集合，Set 集合会删除重复项。因为 Set 集合是可迭代的，所以可以使用 Array.from() 将其转换为一个新的数组。这样，我们就实现了数组去重。 七. 结论Array.from() 方法接受类数组对象以及可迭代对象，它可以接受一个 map 函数，并且，这个 map 函数不会跳过值为 undefined 的数值项。这些特性给 Array.from() 提供了很多可能。如上所述，你可以轻松的将类数组对象转换为数组，克隆一个数组，使用初始化填充数组，生成一个范围，实现数组去重。实际上，Array.from() 是非常好的设计，灵活的配置，允许很多集合转换。","categories":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"}]},{"title":"js 数据类型检测","slug":"js-数据类型检测","date":"2019-08-23T09:21:32.000Z","updated":"2019-08-23T10:03:40.590Z","comments":true,"path":"2019/08/23/js-数据类型检测/","link":"","permalink":"https://staraccompany.gitee.io/blog/2019/08/23/js-数据类型检测/","excerpt":"","text":"1. typeoftypeof 对于基本数据类型的判断是没问题的，但是遇到引用数据类型（如：Array）是不起作用的。 2. instanceofinstanceof 对象字面量创建的基本数据类型(String, Number, Boolean)，但是却不是所属类的实例,返回为false,需要通过 (new Number(1) || new String(“111”) || new Boolean(false)) 才可以得到正确的结果，返回为 true。([],function(){},{})引用数据类型，可以得到正确的结果,返回为 true。null 或者 undefined 会报错 3. constructorconstructor似乎完全可以应对基本数据类型和引用数据类型，都能检测出数据类型。 12345678function Fn()&#123;&#125;;Fn.prototype=new Array();var f=new Fn();console.log(f.constructor===Fn); // falseconsole.log(f.constructor===Array); // true 一个构造函数，并且把他的原型指向了Array的原型，所以这种情况下，constructor也显得力不从心了 4. Object.prototype.toString.call()终极解决办法就是第四种办法，看过jQuery源码的人都知道，jQuery实际上就是采用这个方法进行数据类型检测的。 1Object.prototype.toString.call(&quot;a&quot;) // [object String]","categories":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"}]},{"title":"vue 组件间的传值","slug":"vue-组件间的传值","date":"2019-08-22T09:40:25.000Z","updated":"2019-08-23T03:46:49.069Z","comments":true,"path":"2019/08/22/vue-组件间的传值/","link":"","permalink":"https://staraccompany.gitee.io/blog/2019/08/22/vue-组件间的传值/","excerpt":"","text":"一、 props / @emit父组件通过 props 的方式向子组件传递数据，子组件通过 $emit 向父组件传递通信。 12345678910111213141516171819202122232425262728293031323334&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;child-a :getData=&quot;sendData&quot; @setChild=&quot;getchildData&quot; &gt;&lt;/child-a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childA from &apos;@/test/childA&apos; export default&#123; name:&quot;parent&quot;, components:&#123; childA &#125;, data()&#123; return&#123; sendData:&#123; name:&quot;小白菜&quot;, age:&quot;18&quot;, sex:&quot;man&quot;, &#125;, &#125; &#125;, methods:&#123; // 接收子组件的值 getchildData(val)&#123; console.log(val) //&#123; name:&quot;我是小阔爱&quot;&#125; &#125;, &#125; &#125;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 子组件 childA.vue --&gt;&lt;template&gt; &lt;div class=&quot;childA&quot; @click=&quot;sendParent&quot;&gt;&#123;&#123;getObj.name&#125;&#125;&lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default&#123; name:&quot;childA&quot;, // props 接收父组件的值 props:&#123; getData:&#123; type: Object, default: () =&gt; (&#123;&#125;) &#125; &#125;, watch:&#123; getData:&#123; immediate: true, handler(val) &#123; this.getUnitParentObj = val; &#125; &#125; &#125;, data()&#123; return&#123; getObj: this.getData, &#125; &#125;, methods:&#123; sendParent()&#123; let obj = &#123; name: &quot;我是小阔爱&quot;&#125;; this.$emit(&quot;setChild&quot;,obj); // 给父组件传值 &#125;, &#125; &#125;&lt;/script&gt; 二、 ref / refsref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据。 1234567891011121314// 子组件 childB.vueexport default &#123; data()&#123; return &#123; name:&quot;小阔爱&quot;, &#125; &#125;, methods:&#123; say()&#123; console.log(&quot;miss you&quot;) &#125; &#125;&#125; 1234567891011121314151617181920212223// 父组件 parent.vue&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;child-b ref=&quot;childB&quot; &gt;&lt;/child-b&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childB from &apos;@/test/childB&apos; export default&#123; name:&quot;parent&quot;, components:&#123; childB &#125;, mounted()&#123; const myChild = this.$refs.childB; console.log(myChild.name); //小阔爱 myChild.say(); // miss you &#125;, &#125;&lt;/script&gt; 三、 eventBuseventBus 又称为事件总线，在 vue 中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所有组件都可以通知其他组件。 1. 初始化首先需要创建一个事件总线并将其导出, 以便其他模块可以使用或者监听它. 12345// eventBus.jsimport Vue form &apos;vue&apos;const eventBus = new Vue()export default eventBus 2. 发送事件1234567891011121314&lt;template&gt; &lt;div&gt; &lt;brother-a&gt;&lt;/brother-a&gt; &lt;brother-b&gt;&lt;/brother-b&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import brotherA from &apos;./brotherA.vue&apos; import brotherB from &apos;./brotherB.vue&apos; export default &#123; components: &#123; brotherA, brotherB &#125; &#125;&lt;/script&gt; 12345678910111213141516171819202122// brotherA 中的发送事件&lt;template&gt; &lt;button @click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;/template&gt;&lt;script&gt; import &#123;eventBus&#125; from &apos;./eventBus.js&apos; export default &#123; data()&#123; return&#123; num:1 &#125; &#125;, methods:&#123; add()&#123; eventBus.$emit(&apos;addition&apos;, &#123; num:this.num++ &#125;) &#125; &#125; &#125;&lt;/script&gt; 3. 接收事件12345678910111213141516171819202122232425262728// brotherB 中的接收事件&lt;template&gt; &lt;div&gt;计算和: &#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123;eventBus&#125; from &apos;./eventBus.js&apos; export default &#123; data() &#123; return &#123; count: 0 &#125; &#125;, mounted() &#123; EventBus.$on(&apos;addition&apos;, this.addBind) &#125;, methods:&#123; addBind(&#123;num&#125; = res)&#123; this.count += num; &#125;, &#125;, // 移除监听事件 或者使用第四部分 beforeDestroy()&#123; eventBus.$off(&quot;addition&quot;,this.addBind); &#125; &#125;&lt;/script&gt; 4. 移除事件监听者如果想移除事件的监听, 可以像下面这样操作: 12import &#123; eventBus &#125; from &apos;eventBus.js&apos;EventBus.$off(&apos;addition&apos;, &#123;&#125;) 四、 vuexVuex 是一个专为 Vue.js 应用程序开发的状态管理模式,解决了多个视图依赖于同一状态和来自不同视图的行为需要变更同一状态的问题。 state：用于数据的存储，是store中的唯一数据源getters：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算mutations：类似函数，改变state数据的唯一途径，且不能用于处理异步事件actions：类似于mutation，用于提交mutation来改变状态，而不直接变更状态，可以包含任意异步操作modules：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护 123456789101112131415161718192021222324252627282930// 组件 C&lt;template&gt; &lt;div id=&quot;childC&quot;&gt; &lt;button @click=&quot;sendData&quot;&gt;点我让D组件接收到数据&lt;/button&gt; &lt;p&gt;接受的 D 组件的信息&#123;&#123; DMsg &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; CMsg: &apos;DD你好，我是C&apos; &#125; &#125;, computed: &#123; DMsg() &#123; // 这里存储从store里获取的 D 组件的数据 return this.$store.state.DMsg &#125; &#125;, methods: &#123; sendData() &#123; // 将 C 组件的数据存放到 store 里去 this.$store.commit(&apos;cSendData&apos;, &#123; CMsg: this.CMsg &#125;) &#125; &#125; &#125;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031// 组件 D&lt;template&gt; &lt;div id=&quot;childD&quot;&gt; &lt;button @click=&quot;sendData&quot;&gt;点我让A组件接收到数据&lt;/button&gt; &lt;p&gt;接受的 C 组件的信息：&#123;&#123; CMsg &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; DMsg: &apos;C 你好，我是 DD&apos; &#125; &#125;, computed: &#123; CMsg() &#123; // 这里存储从store里获取的 C 组件的数据 return this.$store.state.CMsg &#125; &#125;, methods: &#123; sendData() &#123; // 将 D 组件的数据存放到 store 里去 this.$store.commit(&apos;dSendData&apos;, &#123; DMsg: this.DMsg &#125;) &#125; &#125; &#125;&lt;/script&gt; 12345678910111213141516171819202122232425import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)const state = &#123; // 初始化 C和 D 组件的数据，等待获取 CMsg: &apos;&apos;, DMsg: &apos;&apos;&#125;const mutations = &#123; cSendData(state, msg) &#123; // 将A组件的数据存放于state state.CMsg = msg.AMsg &#125;, dSendData(state, msg) &#123; // 将B组件的数据存放于state state.DMsg = msg.BMsg &#125;&#125;export default new Vuex.Store(&#123; state, mutations&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/categories/vue/"}],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/tags/vue/"}]},{"title":"爬坑 axios 的 formdata","slug":"爬坑-axios-的-formdata","date":"2019-08-22T04:13:32.000Z","updated":"2019-08-22T07:20:24.712Z","comments":true,"path":"2019/08/22/爬坑-axios-的-formdata/","link":"","permalink":"https://staraccompany.gitee.io/blog/2019/08/22/爬坑-axios-的-formdata/","excerpt":"","text":"在利用axios向后台传数据时，axios默认传的是用application/json格式，若后台需要的数据格式为key/value格式即 formData时，可以在axios的config中进行配置，也可以用qs.stringify()方法进行转换 1.利用 qs.stringify() 进行转换使用脚手架的情况：当你安装 axios 的时候， qs 序列化也一并安装了， 只需要用 import 导入即可 1234567891011121314151617181920import axios from &apos;axios&apos;import qs from &apos;qs&apos; // qs在安装axios后会自动安装，只需要组件里import一下即可function myAxios(method,url,params,contentType)&#123; let headers, data = params; if(contentType == &quot;json&quot;)&#123; headers = &#123; &apos;Content-Type&apos;: &apos; application/json;charset=UTF-8&apos; &#125;; &#125;else&#123; &lt;!-- Form Data --&gt; data = qs.stringify(params); headers = &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded;charset=UTF-8&apos; &#125;; &#125; axios(&#123; method, url, headers, data&#125;).then().catch()&#125; 2. 在 vue axios 中的配置当使用 cdn 在 html 页面中使用 axios 的时候 通过 cdn 引入 123456789101112131415161718192021222324252627&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;function myAxios(method = &quot;POST&quot;,url,params,contentType)&#123; let data = params; let transformRequest; if(contentType == &quot;json&quot;)&#123; data = JSON.stringify(data); axios(&#123; method, url, headers, data, transformRequest&#125;).then().catch() &#125;else&#123; &lt;!-- form data --&gt; data = JSON.stringify(data); transformRequest = [ function(oldData)&#123; // console.log(oldData) let newStr = &apos;&apos;; for (let item in oldData)&#123; newStr += encodeURIComponent(item) + &apos;=&apos; + encodeURIComponent(oldData[item]) + &apos;&amp;&apos; &#125; newStr = newStr.slice(0, -1); return newStr &#125; ] axios(&#123; method, url, headers, data, transformRequest&#125;).then().catch() &#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/categories/vue/"}],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/tags/vue/"}]},{"title":"html2canvas 截图","slug":"html2canvas-截图","date":"2019-07-24T10:04:15.000Z","updated":"2019-07-24T10:31:17.454Z","comments":true,"path":"2019/07/24/html2canvas-截图/","link":"","permalink":"https://staraccompany.gitee.io/blog/2019/07/24/html2canvas-截图/","excerpt":"","text":"html2canvas的基本介绍根据[html2canvas]（http://html2canvas.hertzen.com/documentation）官方文档的介绍，html2canvas库的工作原理并不是真正的“截图”，而是读取网页上的目标DOM节点的信息来绘制canvas，所以它并不支持所有的css属性[（详情参考这里）]（http://html2canvas.hertzen.com/features/），而且期望使用的图片跟当前域名同源，不过官方也提供了一些方法来解决跨域图片的加载问题 html2canvas的限制脚本使用的所有图像都需要位于相同的原点 下，以便能够在没有代理帮助的情况下读取它们。同样，如果您canvas 在页面上有其他元素，这些元素已被污染了跨源内容，它们将变得脏，并且不再被html2canvas读取。 html2canvas的安装1npm install html2canvas 1import html2canvas from &apos;html2canvas&apos;; html2canvas的用法123html2canvas(document.body).then(function(canvas) &#123; document.body.appendChild(canvas);&#125;);","categories":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"}]},{"title":"hexo没有hexo-renderer-sass?","slug":"hexo没有hexo-renderer-sass","date":"2019-07-07T14:10:26.979Z","updated":"2018-11-14T13:32:58.000Z","comments":true,"path":"2019/07/07/hexo没有hexo-renderer-sass/","link":"","permalink":"https://staraccompany.gitee.io/blog/2019/07/07/hexo没有hexo-renderer-sass/","excerpt":"","text":"问题：hexo没有 hexo-renderer-sass?hexo s 能够运行，但是会报错 123(node:9488) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.ERROR Plugin load failed: hexo-renderer-sassPlugin load failed: hexo-renderer-scss 可是已经安装了 12node-sass 4.5.3 (Wrapper) [JavaScript]libsass 3.5.0.beta.2 (Sass Compiler) [C/C++] 解决方案1cnpm install node-sass@latest","categories":[{"name":"hexo","slug":"hexo","permalink":"https://staraccompany.gitee.io/blog/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://staraccompany.gitee.io/blog/tags/hexo/"}]},{"title":" ifram 中遇到的问题 ","slug":"ifram-中遇到的问题","date":"2018-12-31T10:53:13.000Z","updated":"2018-12-31T11:18:58.000Z","comments":true,"path":"2018/12/31/ifram-中遇到的问题/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/12/31/ifram-中遇到的问题/","excerpt":"","text":"当用 jq 写后台系统的时候，就需要镶嵌页面，当你写好的侧边栏和顶部栏的时候，这个时候需要局部舒刷新，不能在每个页面的都去再写一遍相同的侧边栏和顶部，这个时候就要用到 ifram 了。以为在项目中不会再遇到 jq 的后台系统了，可是偏偏就遇到了，然后就先写下个人的一些看法。 1.使用 ifram 的时候子页面高度的自适应123456789adaptiveHeight:function()&#123; function iFrameResize()&#123; //console.log(this.document.body.clientHeight); //弹出当前页面的高度 var obj = parent.document.getElementById(&quot;mainframe1&quot;); //取得父页面IFrame对象 //alert(obj.height); //弹出父页面中IFrame中设置的高度 obj.height = this.document.body.clientHeight+10; //调整父页面中IFrame的高度为此页面的高度 &#125; setTimeout(iFrameResize(),1000)&#125;, 2. 数据字典的封装123456789101112131415161718192021222324function Dictionary()&#123; this.data = new Array(); this.put = function(key,value)&#123; this.data[key] = value; &#125;; this.get = function(key)&#123; return this.data[key]; &#125;; this.remove = function(key)&#123; this.data[key] = null; &#125;; this.isEmpty = function()&#123; return this.data.length == 0; &#125;; this.size = function()&#123; return this.data.length; &#125;;&#125;//使用 例子var d = new Dictionary();d.put(&quot;name&quot;, &quot;Star Accompany&quot;);d.put(&quot;sex&quot;, &quot;Man&quot;);console.log(d.data)document.write(d.get(&quot;name&quot;));","categories":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"}]},{"title":" js 获得时间 星期 ","slug":"js-获得时间-星期","date":"2018-12-31T10:35:17.000Z","updated":"2018-12-31T10:52:48.000Z","comments":true,"path":"2018/12/31/js-获得时间-星期/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/12/31/js-获得时间-星期/","excerpt":"","text":"js 的 获取时间，并且在判断时分秒，小于 10 的时候自动补 0 12345678910111213141516171819202122232425262728getTime: function () &#123; function fill(val)&#123; // 补零 if(val &lt; 10)&#123; val = &apos;0&apos; + val; &#125; return val &#125; function showTime() &#123; var now = new Date(); var year = now.getFullYear(); var month = fill(Number(now.getMonth()) + 1) ; var date = fill(now.getDate()); var week = now.getDay(); //星期 var hour = fill(now.getHours()); //小时 var minu = fill(now.getMinutes());//分钟 var seconds = fill(now.getSeconds());//秒 //判断星期几 var weeks = [&quot;日&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;]; var getWeek = &quot;星期&quot; + weeks[week]; var str = &apos;&apos;; var time = hour + &apos;:&apos; + minu + &apos;:&apos; + seconds + &apos;&apos;; var data = year + &apos;年&apos;+ month + &apos;月&apos; + date + &apos;日&apos;; str = data + &quot; &quot; + getWeek + &quot; &quot; + &quot; &quot; + time; return str // 返回年月日 星期 时分秒 &#125; return showTime(); &#125;,","categories":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"}]},{"title":" 通过 sass 实现换肤功能 ","slug":"通过-sass-实现换肤功能","date":"2018-12-12T08:08:41.000Z","updated":"2018-12-12T15:09:44.000Z","comments":true,"path":"2018/12/12/通过-sass-实现换肤功能/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/12/12/通过-sass-实现换肤功能/","excerpt":"","text":"主要原理： 通过设置html的attribute属性在封装的函数中进行判断，进行相应的设置不同的颜色 css中 [ ] 可以识别到在html标签上设置的属性，所以在html上对应属性发生变化时，就会执行相应的样式， 这一步有点类似于平时给div添加一个.active属性，css自动执行相应样式。 主要文件: base.scss: 一些通用的样式文件 mixin.scss: 定义混合指令 mixin 方法的文件 varibale.scss: 颜色，字体，背景的配置文件 下面是文件： mine.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div&gt; &lt;myheader class=&quot;myheader&quot;&gt;&lt;/myheader&gt; &lt;div&gt;我的 &lt;div class=&quot;zhuti1&quot; @click=&quot;changeThem(&apos;theme1&apos;)&quot;&gt;主题一&lt;/div&gt; &lt;div @click=&quot;changeThem(&apos;theme2&apos;)&quot;&gt;主题二&lt;/div&gt; &lt;div @click=&quot;changeThem(&apos;theme3&apos;)&quot;&gt;主题三&lt;/div&gt; &lt;div @click=&quot;changeThem(&apos;theme4&apos;)&quot;&gt;主题四&lt;/div&gt; &lt;/div&gt; &lt;myfooter&gt;&lt;/myfooter&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import myheader from &quot;@/components/header&quot;;import myfooter from &quot;@/components/footer&quot;;export default &#123; name: &quot;mine&quot;, components: &#123; myheader, myfooter &#125;, data() &#123; return &#123;&#125;; &#125;, methods: &#123; changeThem(them) &#123; window.document.documentElement.setAttribute(&quot;data-theme&quot;, them); console.log(window.document.documentElement.getAttribute(&quot;data-theme&quot;)); &#125; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;@import &quot;../../static/css/base&quot;; @import &quot;../../static/css/mixin&quot;;.myheader&#123; @include bg_color(red)&#125;p &#123; @include px2rem(width, 100px); @include px2rem(height, 100px); @include px2rem(margin, 20px); float: left;&#125;&lt;/style&gt; mixin.scss 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107@charset &quot;utf-8&quot;;@import &quot;./variable&quot;;/*引入配置*/@mixin font_size($size)&#123;/*通过该函数设置字体大小，后期方便统一管理；*/ @include font-dpr($size);&#125;@mixin font_color($color)&#123;/*通过该函数设置字体颜色，后期方便统一管理；*/ color:$color; [data-theme=&quot;theme1&quot;] &amp; &#123; color:$font-color-theme1; &#125; [data-theme=&quot;theme2&quot;] &amp; &#123; color:$font-color-theme2; &#125; [data-theme=&quot;theme3&quot;] &amp; &#123; color:$font-color-theme3; &#125;&#125;@mixin bg_color($color)&#123;/*通过该函数设置主题颜色，后期方便统一管理；*/ background-color:$color; [data-theme=&quot;theme1&quot;] &amp; &#123; background-color:$background-color-theme1; &#125; [data-theme=&quot;theme2&quot;] &amp; &#123; background-color:$background-color-theme2; &#125; [data-theme=&quot;theme3&quot;] &amp; &#123; background-color:$background-color-theme3; &#125;&#125;/*px转rem*/@mixin px2rem($property,$px,$px2:false,$px3:false,$px4:false)&#123; $rem:75px;/* 设计稿尺寸/10 */ @if $px and $px2 and $px3 and $px4 &#123; #&#123;$property&#125;: ($px / $rem) + rem ($px2 / $rem) + rem ($px3 / $rem) + rem ($px4 / $rem) + rem; &#125; @else if $px and $px2 &#123; #&#123;$property&#125;: ($px / $rem) + rem ($px2 / $rem) + rem; //[data-model=&apos;pad&apos;] &amp; &#123;#&#123;$property&#125;: ($px * 1.4 / $rem) + rem ($px2 * 1.4 / $rem) + rem;&#125; &#125; @else&#123; #&#123;$property&#125;: ($px / $rem) + rem!important; //[data-model=&apos;pad&apos;] &amp; &#123;#&#123;$property&#125;: ($px * 1.4 / $rem) + rem;&#125; &#125;&#125;/*根据dpr计算font-size*/@mixin font-dpr($font-size)&#123; font-size: $font-size; //[data-model=&quot;pad&quot;] &amp; &#123; font-size: $font-size * 1.4; &#125; [data-dpr=&quot;2&quot;] &amp; &#123; font-size: $font-size * 2;&#125; [data-dpr=&quot;3&quot;] &amp; &#123; font-size: $font-size * 3;&#125;&#125;/*弹性盒属性*/%flexbox&#123; display: inline-flex;display: -webkit-flex;display: flex;&#125;/*弹性盒比例*/@mixin flex($num:1)&#123; -webkit-box-flex:$num;-moz-box-flex:$num;-webkit-flex:$num;-ms-flex:$num;flex:$num;&#125;/*超行溢出显示省略号*/@mixin overflow($num:1,$fontSize:0,$lineHeight:1.5)&#123; display: -webkit-box;-webkit-line-clamp:$num; overflow: hidden; /*! autoprefixer: off */ -webkit-box-orient: vertical; /* autoprefixer: on */ @if $fontSize!=0 and $lineHeight&#123;/*高度需要撑开*/ line-height:$lineHeight; @if $lineHeight &lt; 1.2 &#123; line-height:1.2; /*最小需要1.2，否则在部分安卓机下第$num+1行会顶部漏出*/ &#125; height: $num * $fontSize * $lineHeight; [data-dpr=&quot;2&quot;] &amp; &#123; height: $num * $fontSize * $lineHeight * 2!important;&#125; [data-dpr=&quot;3&quot;] &amp; &#123; height: $num * $fontSize * $lineHeight * 3!important;&#125; &#125;&#125;//transition兼容写法@mixin transition($content:all .2s)&#123; -moz-transition: $content; -webkit-transition: $content; -o-transition: $content; transition: $content;&#125;//transfrom兼容@mixin translateX($num:-50%)&#123; -ms-transform: translateX($num); -moz-transform: translateX($num); -webkit-transform: translateX($num); -o-transform: translateX($num); transform: translateX($num);&#125;@mixin translateY($num:-50%)&#123; -ms-transform: translateY($num); -moz-transform: translateY($num); -webkit-transform: translateY($num); -o-transform: translateY($num); transform: translateY($num);&#125;@mixin rotate($deg:90deg)&#123; -ms-transform:rotate($deg); -moz-transform:rotate($deg); -webkit-transform:rotate($deg); -o-transform:rotate($deg); transform:rotate($deg);&#125; variable.scss1234567891011121314151617181920212223242526272829303132//颜色定义规范$background-color-theme: #3f8e4d;//背景主题颜色默认$background-color-theme1: red;//背景主题颜色1$background-color-theme2: #652BF5;//背景主题颜色2$background-color-theme3: deepskyblue;//背景主题颜色3$background-color-themesec: #edc148;//背景次要主题颜色$font-color-theme : #3f8e4d;//字体主题颜色默认$font-color-theme1 : red;//字体主题颜色1$font-color-theme2 : #652BF5;//字体主题颜色2$font-color-theme3 : deepskyblue;//字体主题颜色3$font-color-themesec : #edc148;//字体次要主题颜色$font-color-shallow0 : #000;$font-color-shallow1 : #111;$font-color-shallow2 : #222;$font-color-shallow3 : #333;$font-color-shallow4 : #444;$font-color-shallow5 : #555;$font-color-shallow6 : #666;$font-color-shallow7 : #777;$font-color-shallow8 : #888;$font-color-shallow9 : #999;$font-color-shallowdb : #dbdbdb;//字体定义规范$font_little_s:10px;$font_little:12px;$font_medium_s:14px;$font_medium:16px;$font_large_s:18px;$font_large:20px;","categories":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/tags/vue/"}]},{"title":" javascript 中的浅拷贝和深拷贝","slug":"javascript-中的浅拷贝和深拷贝","date":"2018-12-11T08:31:54.000Z","updated":"2019-09-02T08:39:42.049Z","comments":true,"path":"2018/12/11/javascript-中的浅拷贝和深拷贝/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/12/11/javascript-中的浅拷贝和深拷贝/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当发现复制一个对象时，当改变对象新的对象时，原来的对象也发生了变化，原来对象中是按引用传递，它们都是保存在一个内存的同个位置，改变对象时，也改变了引用的地址。但我们往往需要拷贝的是一个新的对象，改变值同时也不改变原来的，这时就需要用到深度拷贝和浅度拷贝了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浅度拷贝： 复制一层对象的属性，并不包括对象里面的为引用类型的数据，当改变拷贝的对象里面的引用类型时，源对象也会改变。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;深度拷贝： 重新开辟一个内存空间，需要递归拷贝对象里的引用，直到子属性都为基本类型。两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。 1、javaScript的变量类型（1）基本类型：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5种基本数据类型Undefined、Null、Boolean、Number 和 String，变量是直接按值存放的，存放在栈内存中的简单数据段，可以直接访问。 （2）引用类型：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存放在堆内存中的对象，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript存储对象都是存地址的，所以浅拷贝会导致 obj1 和obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。 例如：数组拷贝 123456//浅拷贝，双向改变,指向同一片内存空间var arr1 = [1, 2, 3];var arr2 = arr1;arr1[0] = &apos;4&apos;;console.log(&apos;shallow copy: &apos; + arr1 ); //shallow copy: 4,2,3console.log(&apos;shallow copy: &apos; + arr2 ); //shallow copy: 4,2,3 浅拷贝和深拷贝的区分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先深复制和浅复制只针对像 Object, Array 这样的复杂对象的。简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是一个简单的浅复制实现 123456789101112var obj = &#123; a:1, arr: [2,3] &#125;;var shallowObj = shallowCopy(obj);function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅复制会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址,导致的结果就是： 12shallowObj.arr[1] = 5;obj.arr[1] // = 5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而深复制则不同，它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，如果对象比较大，层级也比较多，深复制会带来性能上的问题。在遇到需要采用深复制的场景时，可以考虑有没有其他替代的方案。在实际的应用场景中，也是浅复制更为常用 2、浅拷贝的实现(1).简单的引用复制1234567891011121314function shallowClone(copyObj) &#123; var obj = &#123;&#125;; for ( var i in copyObj) &#123; obj[i] = copyObj[i]; &#125; return obj;&#125;var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = shallowClone(x);console.log(y.b.f === x.b.f); // true (2).Object.assign()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象 1234567var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = Object.assign(&#123;&#125;, x);console.log(y.b.f === x.b.f); // true 添加补充： 12345678910111213141516171819202122&lt;!-- 2019年9月2日16:39:40 --&gt;let copyA = &#123; name:&quot;小白菜&quot;, sex:&quot;男&quot;, age:&quot;18&quot;, intresting:&#123; num1:&quot;eat&quot;, num2:&quot;travel&quot;, num3:&quot;drink&quot; &#125;&#125;let copyB = Object.assign(&#123;&#125;,copyA)console.log(copyA); //&#123;name: &quot;小白菜&quot;, sex: &quot;男&quot;, age: &quot;18&quot;, intresting:&#123; num1:&quot;eat&quot;, num2:&quot;travel&quot;, num3:&quot;drink&quot; &#125;console.log(copyB); //&#123;name: &quot;小白菜&quot;, sex: &quot;男&quot;, age: &quot;18&quot;, intresting:&#123; num1:&quot;eat&quot;, num2:&quot;travel&quot;, num3:&quot;drink&quot; &#125;copyA.age=&quot;19&quot;;copyA.desc=&quot;又大了一岁&quot;;copyA.intresting.num1 = &quot;eat more&quot; console.log(copyA ); //&#123;name: &quot;小白菜&quot;, sex: &quot;男&quot;, age: &quot;19&quot;, intresting:&#123; num1:&quot;eat more&quot;, num2:&quot;travel&quot;, num3:&quot;drink&quot; &#125;,desc:&quot;又大了一岁&quot;&#125;console.log(copyB); //&#123;name: &quot;小白菜&quot;, sex: &quot;男&quot;, age: &quot;18&quot;, intresting:&#123; num1:&quot;eat more&quot;, num2:&quot;travel&quot;, num3:&quot;drink&quot; &#125;&#125; 3、深拷贝的实现(1)、Array的slice和concat方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。之所以把它放在深拷贝里，是因为它看起来像是深拷贝。而实际上它是浅拷贝。原数组的元素会按照下述规则拷贝 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 1234567var array = [1,2,3]; var array_shallow = array; var array_concat = array.concat(); var array_slice = array.slice(0); console.log(array === array_shallow); //true console.log(array === array_slice); //false，“看起来”像深拷贝console.log(array === array_concat); //false，“看起来”像深拷贝 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出，concat和slice返回的不同的数组实例，这与直接的引用复制是不同的。而从另一个例子可以看出Array的concat和slice并不是真正的深复制，数组中的对象元素(Object,Array等)只是复制了引用。如下： 123456789var array = [1, [1,2,3], &#123;name:&quot;array&quot;&#125;]; var array_concat = array.concat();var array_slice = array.slice(0);array_concat[1][0] = 5; //改变array_concat中数组元素的值 console.log(array[1]); //[5,2,3] console.log(array_slice[1]); //[5,2,3] array_slice[2].name = &quot;array_slice&quot;; //改变array_slice中对象元素的值 console.log(array[2].name); //array_sliceconsole.log(array_concat[2].name); //array_slice (2)、JSON对象的parse和stringify&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深拷贝。 123456789101112131415161718//例1var source = &#123; name:&quot;source&quot;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));target.name = &quot;target&quot;; //改变target的name属性console.log(source.name); //source console.log(target.name); //targettarget.child.name = &quot;target child&quot;; //改变target的child console.log(source.child.name); //child console.log(target.child.name); //target child//例2var source = &#123; name:function()&#123;console.log(1);&#125;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefined//例3var source = &#123; name:function()&#123;console.log(1);&#125;, child:new RegExp(&quot;e&quot;) &#125;var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefinedconsole.log(target.child); //Object &#123;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法使用较为简单，可以满足基本的深拷贝需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深拷贝(而且会直接丢失相应的值)。还有一点不好的地方是它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。同时如果对象中存在循环引用的情况也无法正确处理。 4、jQuery.extend()方法源码实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery的源码 - src/core.js #L121源码及分析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354jQuery.extend = jQuery.fn.extend = function() &#123; //给jQuery对象和jQuery原型对象都添加了extend扩展方法 var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false; //以上其中的变量：options是一个缓存变量，用来缓存arguments[i]，name是用来接收将要被扩展对象的key，src改变之前target对象上每个key对应的value。 //copy传入对象上每个key对应的value，copyIsArray判定copy是否为一个数组，clone深拷贝中用来临时存对象或数组的src。 // 处理深拷贝的情况 if (typeof target === &quot;boolean&quot;) &#123; deep = target; target = arguments[1] || &#123;&#125;; //跳过布尔值和目标 i++; &#125; // 控制当target不是object或者function的情况 if (typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target)) &#123; target = &#123;&#125;; &#125; // 当参数列表长度等于i的时候，扩展jQuery对象自身。 if (length === i) &#123; target = this; --i; &#125; for (; i &lt; length; i++) &#123; if ((options = arguments[i]) != null) &#123; // 扩展基础对象 for (name in options) &#123; src = target[name]; copy = options[name]; // 防止永无止境的循环，这里举个例子，如var i = &#123;&#125;;i.a = i;$.extend(true,&#123;&#125;,i);如果没有这个判断变成死循环了 if (target === copy) &#123; continue; &#125; if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) &#123; if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src: []; // 如果src存在且是数组的话就让clone副本等于src否则等于空数组。 &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src: &#123;&#125;; // 如果src存在且是对象的话就让clone副本等于src否则等于空数组。 &#125; // 递归拷贝 target[name] = jQuery.extend(deep, clone, copy); &#125; else if (copy !== undefined) &#123; target[name] = copy; // 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性。 &#125; &#125; &#125; &#125; // 返回修改的对象 return target;&#125;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery的extend方法使用基本的递归思路实现了浅拷贝和深拷贝，但是这个方法也无法处理源对象内部循环引用，例如： 12345var a = &#123;&quot;name&quot;:&quot;aaa&quot;&#125;;var b = &#123;&quot;name&quot;:&quot;bbb&quot;&#125;;a.child = b;b.parent = a;$.extend(true,&#123;&#125;,a);//直接报了栈溢出。Uncaught RangeError: Maximum call stack size exceeded 参考文章：https://github.com/wengjq/Blog/issues/3 参考文章: https://www.zhihu.com/question/23031215/answer/46220227","categories":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"}]},{"title":" 消息弹框 ","slug":"消息弹框","date":"2018-12-07T09:29:10.000Z","updated":"2018-12-12T15:08:38.000Z","comments":true,"path":"2018/12/07/消息弹框/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/12/07/消息弹框/","excerpt":"","text":"vue 中封装的 showTotast 和 heideLoading123456789101112131415161718192021222324252627282930313233343536.win &#123; width: 100%; height: 100%; position: fixed; top: 0; z-index: 99; text-align: center;&#125;.cue &#123; background: rgba(0, 0, 0, 0.6); color: #fff; padding: 0.14rem; margin: 65% auto; border-radius: 0.08rem; font-size: 0.14rem; display: inline-table; z-index: 99999;&#125;&lt;div class=&quot;win&quot; v-if=&quot;msg != &apos;&apos;&quot;&gt; &lt;div class=&quot;cue&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/div&gt;// showtotast 当前的 this 指向，消息内容showTotast: function(_this, msg) &#123; _this.msg = msg; setTimeout(function() &#123; _this.msg = &quot;&quot;; &#125;, 2000);&#125;,// cancelLoadinghideLoading: function(_this) &#123; setTimeout(function() &#123; _this.msg = &quot;&quot;; &#125;, 400);&#125;,","categories":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/tags/vue/"}]},{"title":" ajax 请求，返回值为 304 Not Modify 错误原因与解决办法","slug":"ajax-请求，返回值为-304-Not-Modify-错误原因与解决办法","date":"2018-12-07T09:13:38.000Z","updated":"2018-12-12T15:13:10.000Z","comments":true,"path":"2018/12/07/ajax-请求，返回值为-304-Not-Modify-错误原因与解决办法/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/12/07/ajax-请求，返回值为-304-Not-Modify-错误原因与解决办法/","excerpt":"","text":"原因：因为 http 的请求缓存问题引起的，前后调用相同的两个请求，服务器比较懒，不想给你重新发送一个请求，所以就用了缓存从而产生304了解决方案：加一个时间戳1234axios.get(&quot;postData.json?&quot;) .then(res =&gt; &#123; // to do something &#125;); 那么我们加一个参数就行了，这个参数没有什么实际意义，但是可以帮助我们让每次发的请求都不一样 123456let date = new Date();let timer = date.getTime().toString();axios.get(&quot;postData.json?timer=&quot; + timer) .then(res =&gt; &#123; //to do something &#125;);","categories":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"}]},{"title":" js 去除空字符串、空格 ","slug":"js-去除空字符串、空格","date":"2018-12-05T08:02:53.000Z","updated":"2018-12-12T15:11:48.000Z","comments":true,"path":"2018/12/05/js-去除空字符串、空格/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/12/05/js-去除空字符串、空格/","excerpt":"","text":"使用 js 去除字符串的方法有三种： 1. 使用正则 replace 匹配 去除字符串内所有的空格：str = str.replace(/\\s*/g,””); 去除字符串内两头的空格：str = str.replace(/^\\s|\\s$/g,””); 去除字符串内左侧的空格：str = str.replace(/^\\s*/,””); 去除字符串内右侧的空格：str = str.replace(/(\\s*$)/g,””); 2. str.trim()方法trim()方法是用来删除字符串两端的空白字符并返回，trim方法并不影响原来的字符串本身，它返回的是一个新的字符串。 缺陷：只能去除字符串两端的空格，不能去除中间的空格 单独去除左侧空格则使用 str.trimLeft(); //var str_1 = str.trimLeft(); 单独去除右侧空格则使用 str.trimRight();//var str_1 = str.trimRight(); 3. JQ方法：$.trim(str)方法 $.trim() 函数用于去除字符串两端的空白字符。 注意：$.trim()函数会移除字符串开始和末尾处的所有换行符，空格(包括连续的空格)和制表符。如果这些空白字符在字符串中间时，它们将被保留，不会被移除。","categories":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"}]},{"title":"截取url后面的参数","slug":"截取url后面的参数","date":"2018-12-04T07:44:14.000Z","updated":"2018-12-12T15:10:10.000Z","comments":true,"path":"2018/12/04/截取url后面的参数/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/12/04/截取url后面的参数/","excerpt":"","text":"JS 获取 url 传递参数，JS 获取 url? 后面的参数方法一： 正则表达式123456function getParam(name) &#123; var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125;, 方法二：123456789101112function GetRequest() &#123; var url = location.search; //获取url中&quot;?&quot;符后的字串 var theRequest = new Object(); if (url.indexOf(&quot;?&quot;) != -1) &#123; var str = url.substr(1); strs = str.split(&quot;&amp;&quot;); for (var i = 0; i &lt; strs.length; i++) &#123; theRequest[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]); &#125; &#125; return theRequest;&#125; 方法三：123456789101112131415161718192021222324252627/** * 获取指定的URL参数值 * URL:http://www.quwan.com/index?name=tyler * 参数：paramName URL参数 * 调用方法:getParam(&quot;name&quot;) * 返回值:tyler */function getParam(paramName) &#123; (paramValue = &quot;&quot;), (isFound = !1); if ( this.location.search.indexOf(&quot;?&quot;) == 0 &amp;&amp; this.location.search.indexOf(&quot;=&quot;) &gt; 1 ) &#123; (arrSource = unescape(this.location.search) .substring(1, this.location.search.length) .split(&quot;&amp;&quot;)), (i = 0); while (i &lt; arrSource.length &amp;&amp; !isFound) arrSource[i].indexOf(&quot;=&quot;) &gt; 0 &amp;&amp; arrSource[i].split(&quot;=&quot;)[0].toLowerCase() == paramName.toLowerCase() &amp;&amp; ((paramValue = arrSource[i].split(&quot;=&quot;)[1]), (isFound = !0)), i++; &#125; return paramValue == &quot;&quot; &amp;&amp; (paramValue = null), paramValue;&#125;","categories":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://staraccompany.gitee.io/blog/tags/js/"}]},{"title":"vue实现 H5 的粘贴复制功能","slug":"vue实现-H5-的粘贴复制功能","date":"2018-11-23T07:08:47.000Z","updated":"2018-12-12T15:11:18.000Z","comments":true,"path":"2018/11/23/vue实现-H5-的粘贴复制功能/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/11/23/vue实现-H5-的粘贴复制功能/","excerpt":"","text":"github上有一个开源的基于上述方法实现的插件clipboardjs。他可以实现复制，剪切，黏贴操作。具体调用如下12345678910111213141516171819202122&lt;div class=&quot;copy&quot;&gt;复制内容的&lt;/div&gt;&lt;buttonclass=&quot;btn&quot;data-clipboard-action=&quot;copy&quot;data-clipboard-target=&quot;.copy&quot;&gt;Copy&lt;/button&gt;&lt;script src=&quot;js/clipboard.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var clipboard = new ClipboardJS(&quot;.btn&quot;); clipboard.on(&quot;success&quot;, function(e) &#123; console.info(&quot;Action:&quot;, e.action); console.info(&quot;Text:&quot;, e.text); console.info(&quot;Trigger:&quot;, e.trigger); e.clearSelection(); &#125;); clipboard.on(&quot;error&quot;, function(e) &#123; console.error(&quot;Action:&quot;, e.action); console.error(&quot;Trigger:&quot;, e.trigger); &#125;);&lt;/script&gt; vue的使用npm使用例子https://www.npmjs.com/package/vue-clipboard2","categories":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/tags/vue/"}]},{"title":"小程序封装的登录实现用户的无感登录","slug":"小程序封装的登录实现用户的无感登录","date":"2018-11-15T16:00:55.000Z","updated":"2018-11-15T16:33:06.000Z","comments":true,"path":"2018/11/16/小程序封装的登录实现用户的无感登录/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/11/16/小程序封装的登录实现用户的无感登录/","excerpt":"","text":"在最初写小程序的时候将登录做成一个单独的页面，在用户开始的时候从登录页点击，授权进入，一套流程很舒服，后面产品需求加了登录的过期处理 &#160;&#160;&#160;&#160;1.在用户第一次授权点击登录按钮之后，后面的登录不再经过登录页面；&#160;&#160;&#160;&#160;2.在登录的时候只静默在后台进行，用户是感知不到的；&#160;&#160;&#160;&#160;3.当分享给一个新用户的时候，用户走注册登录流程页面之后仍然还是这个页面，不进行页面的跳转； 拿到这个需求的时候作为一个刚开始写小程序的菜鸟的我头都炸了，经过一系列的分析有了明确的思路 &#160;&#160;&#160;&#160;1.需要在每个页面都要一个遮罩层，然后就写了登录的模板，在每个页面中都引用；&#160;&#160;&#160;&#160;2.封装登录的方法，包含点击登录和自动登录；&#160;&#160;&#160;&#160;3.自动登录的时候需要判断登录时间是否过期，因此需要重新封装微信的存储方法，通过时间戳比较，从而刷新用户的登录状态（在判断时间戳的时候，建议前端设置的过期时间要小于后端设置的过期时间） 第二种方法：设置请求拦截，在wx.request 方法中加一个拦截器，当返回登录过期的时候，进行拦截，当一个页面中有多个数据请求的时候，需要利用promise 的方法，阻止后面的数据的请求，不然你的页面发起多少个请求就会发起多少次登录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149var app = getApp();// 设置存储时间const lifeTime = 60 * 60 * 24 * 7;/** * 入口函数 */export default function main(callback) &#123; var api_token = app.getCookie(&apos;api_token&apos;); if (api_token)&#123; typeof callback ===&apos;function&apos;?callback():&apos;&apos;; return ; &#125; var pages = getCurrentPages(); //获取加载的页面 var currentPage = pages[pages.length - 1]; //获取当前页面的对象 loginInfo(function()&#123; typeof callback === &apos;function&apos; ? callback() : &apos;&apos;; &#125;,function()&#123; wx.hideLoading() currentPage.setData(&#123; authorizationStatus:true &#125;) currentPage.bindGetUserInfo = bindGetUserInfo; currentPage.bindUserInfCallback = function()&#123; currentPage.setData(&#123; authorizationStatus: false &#125;) typeof callback === &apos;function&apos; ? callback() : &apos;&apos;; &#125; &#125;);&#125;// 通过按钮点击的的登录function bindGetUserInfo(e) &#123; var that = this; var userInfo = e.userInfo; var detail = e.detail; if (!detail.userInfo) &#123; return wx.showToast(&#123; title: &apos;您拒绝了授权，无法正常访问!&apos;, icon: &apos;none&apos; &#125;) &#125; that.bindUserInfCallback(); var userInfo = detail.userInfo; wx.login(&#123; success: res =&gt; &#123; // 发送 res.code 到后台换取 openId, sessionKey, unionId var code = res.code; var username = userInfo.nickName; var avatarUrl = userInfo.avatarUrl; var gender = userInfo.gender //性别 0：未知、1：男、2：女 var province = userInfo.province; var city = userInfo.city; var share_user_id = wx.getStorageSync(&apos;share_user_id&apos;) var country = userInfo.country; app.getAjax(app.API.login, &#123; code: code, encrypted: detail.encryptedData, share_user_id: share_user_id, iv: detail.iv &#125;, (resu) =&gt; &#123; if (resu.status) &#123; var api_token = resu.result.userInfo.api_token; var user_id = resu.result.userInfo.user_id; app.setCookie(&apos;headimg&apos;, avatarUrl,lifeTime); app.setCookie(&apos;username&apos;, username, lifeTime); app.setCookie(&apos;city&apos;, city, lifeTime); app.setCookie(&apos;gender&apos;, gender, lifeTime); app.setCookie(&quot;user_id&quot;, user_id, lifeTime); app.setCookie(&quot;api_token&quot;, api_token, lifeTime); wx.removeStorageSync(&apos;share_user_id&apos;) that.bindUserInfCallback(); &#125; else &#123; console.log(resu) wx.showToast(&#123; icon: &apos;none&apos;, title: resu, &#125;) &#125; &#125;) &#125;, fail: (err) =&gt; &#123; wx.showToast(&#123; title: err, icon: &apos;none&apos; &#125;); &#125; &#125;)&#125;// 过期自动登录function loginInfo(success,error) &#123; var that = this; wx.login(&#123; success: res =&gt; &#123; // 发送 res.code 到后台换取 openId, sessionKey, unionId var code = res.code; wx.getUserInfo(&#123; lang: &apos;zh_CN&apos;, success: function (data) &#123; console.log(data) var userInfo = data.userInfo; var username = userInfo.nickName; var avatarUrl = userInfo.avatarUrl; var gender = userInfo.gender //性别 0：未知、1：男、2：女 var province = userInfo.province; var city = userInfo.city; var country = userInfo.country; var share_user_id = wx.getStorageSync(&apos;share_user_id&apos;) app.getAjax(app.API.login, &#123; code: code, encrypted: data.encryptedData, iv: data.iv, share_user_id: share_user_id &#125;, (resu) =&gt; &#123; if (resu.status) &#123; var api_token = resu.result.userInfo.api_token; var user_id = resu.result.userInfo.user_id; app.setCookie(&apos;headimg&apos;, avatarUrl, lifeTime); app.setCookie(&apos;username&apos;, username, lifeTime); app.setCookie(&apos;city&apos;, city, lifeTime); app.setCookie(&apos;gender&apos;, gender, lifeTime); app.setCookie(&quot;user_id&quot;, user_id, lifeTime); app.setCookie(&quot;api_token&quot;, api_token, lifeTime); console.log(share_user_id) wx.removeStorageSync(&apos;share_user_id&apos;) typeof success === &apos;function&apos;? success():&apos;&apos;; &#125; else &#123; wx.showToast(&#123; icon: &apos;none&apos;, title: resu, &#125;) &#125; &#125;) &#125;, fail: (err) =&gt; &#123; typeof error ===&apos;function&apos; ? error() :&apos;&apos;; &#125; &#125;) &#125;, fail: res =&gt; &#123; wx.showToast(&#123; icon: &apos;none&apos;, title: res, &#125;) &#125; &#125;)&#125;","categories":[{"name":"小程序","slug":"小程序","permalink":"https://staraccompany.gitee.io/blog/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://staraccompany.gitee.io/blog/tags/小程序/"}]},{"title":"js实现上拉加载兼容移动端","slug":"js实现上拉加载兼容移动端","date":"2018-11-15T15:38:08.000Z","updated":"2018-11-15T15:49:00.000Z","comments":true,"path":"2018/11/15/js实现上拉加载兼容移动端/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/11/15/js实现上拉加载兼容移动端/","excerpt":"","text":"vue中封装的简易的上拉加载js的公共方法 123456789101112131415161718192021222324252627282930313233343536_reachBottom(url,data,callback) &#123; // api 参数 回调函数 let _this = this; if (url) &#123; window.addEventListener(&quot;scroll&quot;, function() &#123; // 监听滚动条 let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop; // 兼容 ios 和 android 的滚动 if ( scrollTop + document.documentElement.clientHeight == document.body.scrollHeight ) &#123; if (_this.page &gt;= _this.pages) &#123; // 判断是否上拉加载 _this.errStaus = true; _this.errInfo = &quot;已经没有新的数据了&quot;; setTimeout(function() &#123; _this.errStaus = false; &#125;, 2000); // 弹框的自动取消 return; &#125; else if (_this.page &lt; _this.pages &amp;&amp; _this.pages != 1) &#123; load(_this); // 加载中的方法 _this.page+=1; data.page = _this.page _this._http(url, data, function(res) &#123; _this.msg = res.message; if (res.code == 200) &#123; callback.call(null, res.datas); &#125; &#125;); &#125; &#125; &#125;); &#125; else &#123; return false; &#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/tags/vue/"}]},{"title":"vue-遮罩阻止默认滚动事件","slug":"vue-遮罩阻止默认滚动事件","date":"2018-11-14T13:29:33.000Z","updated":"2018-11-14T13:32:56.000Z","comments":true,"path":"2018/11/14/vue-遮罩阻止默认滚动事件/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/11/14/vue-遮罩阻止默认滚动事件/","excerpt":"","text":"vue中提供 @touchmove.prevent 方法可以完美解决这个问题。1&lt;div class=&quot;child&quot; @touchmove.prevent &gt;&lt;/div&gt; vue 同时还提供了其他的修饰符1.阻止单击事件的继续传播：1&lt;a class=&quot;child&quot; v-on:click.stop=&apos;doThis&apos; &gt;&lt;/a&gt; 2.提交事件不再重载页面 ：1&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; 3.修饰符可以串联 ：1&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt; 4.只有修饰符 ：1&lt;form v-on:submit.prevent&gt;&lt;/form&gt; 5.添加事件监听器时使用事件捕获模式， 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 ：1&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt; 6.只当在 event.target 是当前元素自身时触发处理函数 ，即事件不是从内部元素触发的 ：1&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://staraccompany.gitee.io/blog/tags/vue/"}]},{"title":"markdown的基本语法","slug":"markdown的基本语法","date":"2018-11-10T06:33:27.000Z","updated":"2018-11-10T11:09:34.000Z","comments":true,"path":"2018/11/10/markdown的基本语法/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/11/10/markdown的基本语法/","excerpt":"","text":"1. 标题的几种写法# 一级标题 ## 二级标题 ### 三级标题 ... ####### 七级标题&#160;tips:markdown在线编辑器 2. 列表无序列表* 1=》·1 + 2=》·2 - 3=》·3 可以看到，无序列表可以用* ， + ， — 来创建，用在线编辑器看，实际上是转换成了ul&gt;li ，所以使用哪个都可以，推荐使用*吧 有序列表有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的3.区块引用用法就是在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格 比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句 &gt;搞IT太辛苦了，想换一行怎么办？”“敲一下Enter键。” 搞IT太辛苦了，想换一行怎么办？”“敲一下Enter键。” 4.分割线分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以 *** --- _ _ _5.链接支持2种链接方式：行内式和参数式，不管是哪一种，链接文字都是用 [方括号] 来标记。 [百度]（https://baidu.com）=&gt; &#160;百度","categories":[{"name":"markdown","slug":"markdown","permalink":"https://staraccompany.gitee.io/blog/categories/markdown/"}],"tags":[]},{"title":"hexo 创建文章、标签、分类","slug":"hexo-创建文章、标签、分类","date":"2018-11-10T06:08:45.000Z","updated":"2019-07-16T08:37:27.368Z","comments":true,"path":"2018/11/10/hexo-创建文章、标签、分类/","link":"","permalink":"https://staraccompany.gitee.io/blog/2018/11/10/hexo-创建文章、标签、分类/","excerpt":"","text":"1.创建文章&#160;&#160;&#160;&#160;在hexo下创建一个新的文章 hexo new ‘文章名称’ 创建成功后会提示你创建在文件路径，一般都在 hexo/source/_posts 下 &#160;&#160;&#160;&#160;文章的基本设置 title: 文章名字date: 2018年11月10日14:14:13comments: true #是否可以评论toc: true # 是否显示文章目录categories: ‘hexo创建文章的基本设置’ #分类tage: #标签 2.创建标签、分类&#160;&#160;&#160;&#160;创建标签页面 hexo new page tags &#160;&#160;&#160;&#160;创建分类 hexo new page categories","categories":[{"name":"hexo","slug":"hexo","permalink":"https://staraccompany.gitee.io/blog/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://staraccompany.gitee.io/blog/tags/hexo/"}]}]}