{"meta":{"title":"夕阳残雪的博客","subtitle":null,"description":null,"author":"Zihao","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"hexo没有hexo-renderer-sass?","slug":"hexo没有hexo-renderer-sass","date":"2019-07-07T14:10:26.979Z","updated":"2018-11-14T13:32:58.000Z","comments":true,"path":"2019/07/07/hexo没有hexo-renderer-sass/","link":"","permalink":"http://yoursite.com/2019/07/07/hexo没有hexo-renderer-sass/","excerpt":"","text":"问题：hexo没有 hexo-renderer-sass?hexo s 能够运行，但是会报错 123(node:9488) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.ERROR Plugin load failed: hexo-renderer-sassPlugin load failed: hexo-renderer-scss 可是已经安装了 12node-sass 4.5.3 (Wrapper) [JavaScript]libsass 3.5.0.beta.2 (Sass Compiler) [C/C++] 解决方案1cnpm install node-sass@latest","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":" ifram 中遇到的问题 ","slug":"ifram-中遇到的问题","date":"2018-12-31T10:53:13.000Z","updated":"2018-12-31T11:18:58.000Z","comments":true,"path":"2018/12/31/ifram-中遇到的问题/","link":"","permalink":"http://yoursite.com/2018/12/31/ifram-中遇到的问题/","excerpt":"","text":"当用 jq 写后台系统的时候，就需要镶嵌页面，当你写好的侧边栏和顶部栏的时候，这个时候需要局部舒刷新，不能在每个页面的都去再写一遍相同的侧边栏和顶部，这个时候就要用到 ifram 了。以为在项目中不会再遇到 jq 的后台系统了，可是偏偏就遇到了，然后就先写下个人的一些看法。 1.使用 ifram 的时候子页面高度的自适应123456789adaptiveHeight:function()&#123; function iFrameResize()&#123; //console.log(this.document.body.clientHeight); //弹出当前页面的高度 var obj = parent.document.getElementById(&quot;mainframe1&quot;); //取得父页面IFrame对象 //alert(obj.height); //弹出父页面中IFrame中设置的高度 obj.height = this.document.body.clientHeight+10; //调整父页面中IFrame的高度为此页面的高度 &#125; setTimeout(iFrameResize(),1000)&#125;, 2. 数据字典的封装123456789101112131415161718192021222324function Dictionary()&#123; this.data = new Array(); this.put = function(key,value)&#123; this.data[key] = value; &#125;; this.get = function(key)&#123; return this.data[key]; &#125;; this.remove = function(key)&#123; this.data[key] = null; &#125;; this.isEmpty = function()&#123; return this.data.length == 0; &#125;; this.size = function()&#123; return this.data.length; &#125;;&#125;//使用 例子var d = new Dictionary();d.put(&quot;name&quot;, &quot;Star Accompany&quot;);d.put(&quot;sex&quot;, &quot;Man&quot;);console.log(d.data)document.write(d.get(&quot;name&quot;));","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":" js 获得时间 星期 ","slug":"js-获得时间-星期","date":"2018-12-31T10:35:17.000Z","updated":"2018-12-31T10:52:48.000Z","comments":true,"path":"2018/12/31/js-获得时间-星期/","link":"","permalink":"http://yoursite.com/2018/12/31/js-获得时间-星期/","excerpt":"","text":"js 的 获取时间，并且在判断时分秒，小于 10 的时候自动补 0 12345678910111213141516171819202122232425262728getTime: function () &#123; function fill(val)&#123; // 补零 if(val &lt; 10)&#123; val = &apos;0&apos; + val; &#125; return val &#125; function showTime() &#123; var now = new Date(); var year = now.getFullYear(); var month = fill(Number(now.getMonth()) + 1) ; var date = fill(now.getDate()); var week = now.getDay(); //星期 var hour = fill(now.getHours()); //小时 var minu = fill(now.getMinutes());//分钟 var seconds = fill(now.getSeconds());//秒 //判断星期几 var weeks = [&quot;日&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;]; var getWeek = &quot;星期&quot; + weeks[week]; var str = &apos;&apos;; var time = hour + &apos;:&apos; + minu + &apos;:&apos; + seconds + &apos;&apos;; var data = year + &apos;年&apos;+ month + &apos;月&apos; + date + &apos;日&apos;; str = data + &quot; &quot; + getWeek + &quot; &quot; + &quot; &quot; + time; return str // 返回年月日 星期 时分秒 &#125; return showTime(); &#125;,","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":" 通过 sass 实现换肤功能 ","slug":"通过-sass-实现换肤功能","date":"2018-12-12T08:08:41.000Z","updated":"2018-12-12T15:09:44.000Z","comments":true,"path":"2018/12/12/通过-sass-实现换肤功能/","link":"","permalink":"http://yoursite.com/2018/12/12/通过-sass-实现换肤功能/","excerpt":"","text":"主要原理： 通过设置html的attribute属性在封装的函数中进行判断，进行相应的设置不同的颜色 css中 [ ] 可以识别到在html标签上设置的属性，所以在html上对应属性发生变化时，就会执行相应的样式， 这一步有点类似于平时给div添加一个.active属性，css自动执行相应样式。 主要文件: base.scss: 一些通用的样式文件 mixin.scss: 定义混合指令 mixin 方法的文件 varibale.scss: 颜色，字体，背景的配置文件 下面是文件： mine.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div&gt; &lt;myheader class=&quot;myheader&quot;&gt;&lt;/myheader&gt; &lt;div&gt;我的 &lt;div class=&quot;zhuti1&quot; @click=&quot;changeThem(&apos;theme1&apos;)&quot;&gt;主题一&lt;/div&gt; &lt;div @click=&quot;changeThem(&apos;theme2&apos;)&quot;&gt;主题二&lt;/div&gt; &lt;div @click=&quot;changeThem(&apos;theme3&apos;)&quot;&gt;主题三&lt;/div&gt; &lt;div @click=&quot;changeThem(&apos;theme4&apos;)&quot;&gt;主题四&lt;/div&gt; &lt;/div&gt; &lt;myfooter&gt;&lt;/myfooter&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import myheader from &quot;@/components/header&quot;;import myfooter from &quot;@/components/footer&quot;;export default &#123; name: &quot;mine&quot;, components: &#123; myheader, myfooter &#125;, data() &#123; return &#123;&#125;; &#125;, methods: &#123; changeThem(them) &#123; window.document.documentElement.setAttribute(&quot;data-theme&quot;, them); console.log(window.document.documentElement.getAttribute(&quot;data-theme&quot;)); &#125; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;@import &quot;../../static/css/base&quot;; @import &quot;../../static/css/mixin&quot;;.myheader&#123; @include bg_color(red)&#125;p &#123; @include px2rem(width, 100px); @include px2rem(height, 100px); @include px2rem(margin, 20px); float: left;&#125;&lt;/style&gt; mixin.scss 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107@charset &quot;utf-8&quot;;@import &quot;./variable&quot;;/*引入配置*/@mixin font_size($size)&#123;/*通过该函数设置字体大小，后期方便统一管理；*/ @include font-dpr($size);&#125;@mixin font_color($color)&#123;/*通过该函数设置字体颜色，后期方便统一管理；*/ color:$color; [data-theme=&quot;theme1&quot;] &amp; &#123; color:$font-color-theme1; &#125; [data-theme=&quot;theme2&quot;] &amp; &#123; color:$font-color-theme2; &#125; [data-theme=&quot;theme3&quot;] &amp; &#123; color:$font-color-theme3; &#125;&#125;@mixin bg_color($color)&#123;/*通过该函数设置主题颜色，后期方便统一管理；*/ background-color:$color; [data-theme=&quot;theme1&quot;] &amp; &#123; background-color:$background-color-theme1; &#125; [data-theme=&quot;theme2&quot;] &amp; &#123; background-color:$background-color-theme2; &#125; [data-theme=&quot;theme3&quot;] &amp; &#123; background-color:$background-color-theme3; &#125;&#125;/*px转rem*/@mixin px2rem($property,$px,$px2:false,$px3:false,$px4:false)&#123; $rem:75px;/* 设计稿尺寸/10 */ @if $px and $px2 and $px3 and $px4 &#123; #&#123;$property&#125;: ($px / $rem) + rem ($px2 / $rem) + rem ($px3 / $rem) + rem ($px4 / $rem) + rem; &#125; @else if $px and $px2 &#123; #&#123;$property&#125;: ($px / $rem) + rem ($px2 / $rem) + rem; //[data-model=&apos;pad&apos;] &amp; &#123;#&#123;$property&#125;: ($px * 1.4 / $rem) + rem ($px2 * 1.4 / $rem) + rem;&#125; &#125; @else&#123; #&#123;$property&#125;: ($px / $rem) + rem!important; //[data-model=&apos;pad&apos;] &amp; &#123;#&#123;$property&#125;: ($px * 1.4 / $rem) + rem;&#125; &#125;&#125;/*根据dpr计算font-size*/@mixin font-dpr($font-size)&#123; font-size: $font-size; //[data-model=&quot;pad&quot;] &amp; &#123; font-size: $font-size * 1.4; &#125; [data-dpr=&quot;2&quot;] &amp; &#123; font-size: $font-size * 2;&#125; [data-dpr=&quot;3&quot;] &amp; &#123; font-size: $font-size * 3;&#125;&#125;/*弹性盒属性*/%flexbox&#123; display: inline-flex;display: -webkit-flex;display: flex;&#125;/*弹性盒比例*/@mixin flex($num:1)&#123; -webkit-box-flex:$num;-moz-box-flex:$num;-webkit-flex:$num;-ms-flex:$num;flex:$num;&#125;/*超行溢出显示省略号*/@mixin overflow($num:1,$fontSize:0,$lineHeight:1.5)&#123; display: -webkit-box;-webkit-line-clamp:$num; overflow: hidden; /*! autoprefixer: off */ -webkit-box-orient: vertical; /* autoprefixer: on */ @if $fontSize!=0 and $lineHeight&#123;/*高度需要撑开*/ line-height:$lineHeight; @if $lineHeight &lt; 1.2 &#123; line-height:1.2; /*最小需要1.2，否则在部分安卓机下第$num+1行会顶部漏出*/ &#125; height: $num * $fontSize * $lineHeight; [data-dpr=&quot;2&quot;] &amp; &#123; height: $num * $fontSize * $lineHeight * 2!important;&#125; [data-dpr=&quot;3&quot;] &amp; &#123; height: $num * $fontSize * $lineHeight * 3!important;&#125; &#125;&#125;//transition兼容写法@mixin transition($content:all .2s)&#123; -moz-transition: $content; -webkit-transition: $content; -o-transition: $content; transition: $content;&#125;//transfrom兼容@mixin translateX($num:-50%)&#123; -ms-transform: translateX($num); -moz-transform: translateX($num); -webkit-transform: translateX($num); -o-transform: translateX($num); transform: translateX($num);&#125;@mixin translateY($num:-50%)&#123; -ms-transform: translateY($num); -moz-transform: translateY($num); -webkit-transform: translateY($num); -o-transform: translateY($num); transform: translateY($num);&#125;@mixin rotate($deg:90deg)&#123; -ms-transform:rotate($deg); -moz-transform:rotate($deg); -webkit-transform:rotate($deg); -o-transform:rotate($deg); transform:rotate($deg);&#125; variable.scss1234567891011121314151617181920212223242526272829303132//颜色定义规范$background-color-theme: #3f8e4d;//背景主题颜色默认$background-color-theme1: red;//背景主题颜色1$background-color-theme2: #652BF5;//背景主题颜色2$background-color-theme3: deepskyblue;//背景主题颜色3$background-color-themesec: #edc148;//背景次要主题颜色$font-color-theme : #3f8e4d;//字体主题颜色默认$font-color-theme1 : red;//字体主题颜色1$font-color-theme2 : #652BF5;//字体主题颜色2$font-color-theme3 : deepskyblue;//字体主题颜色3$font-color-themesec : #edc148;//字体次要主题颜色$font-color-shallow0 : #000;$font-color-shallow1 : #111;$font-color-shallow2 : #222;$font-color-shallow3 : #333;$font-color-shallow4 : #444;$font-color-shallow5 : #555;$font-color-shallow6 : #666;$font-color-shallow7 : #777;$font-color-shallow8 : #888;$font-color-shallow9 : #999;$font-color-shallowdb : #dbdbdb;//字体定义规范$font_little_s:10px;$font_little:12px;$font_medium_s:14px;$font_medium:16px;$font_large_s:18px;$font_large:20px;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":" javascript 中的浅拷贝和深拷贝","slug":"javascript-中的浅拷贝和深拷贝","date":"2018-12-11T08:31:54.000Z","updated":"2018-12-12T15:12:44.000Z","comments":true,"path":"2018/12/11/javascript-中的浅拷贝和深拷贝/","link":"","permalink":"http://yoursite.com/2018/12/11/javascript-中的浅拷贝和深拷贝/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当发现复制一个对象时，当改变对象新的对象时，原来的对象也发生了变化，原来对象中是按引用传递，它们都是保存在一个内存的同个位置，改变对象时，也改变了引用的地址。但我们往往需要拷贝的是一个新的对象，改变值同时也不改变原来的，这时就需要用到深度拷贝和浅度拷贝了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浅度拷贝： 复制一层对象的属性，并不包括对象里面的为引用类型的数据，当改变拷贝的对象里面的引用类型时，源对象也会改变。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;深度拷贝： 重新开辟一个内存空间，需要递归拷贝对象里的引用，直到子属性都为基本类型。两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。 1、javaScript的变量类型（1）基本类型：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5种基本数据类型Undefined、Null、Boolean、Number 和 String，变量是直接按值存放的，存放在栈内存中的简单数据段，可以直接访问。 （2）引用类型：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存放在堆内存中的对象，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript存储对象都是存地址的，所以浅拷贝会导致 obj1 和obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。 例如：数组拷贝 123456//浅拷贝，双向改变,指向同一片内存空间var arr1 = [1, 2, 3];var arr2 = arr1;arr1[0] = &apos;4&apos;;console.log(&apos;shallow copy: &apos; + arr1 ); //shallow copy: 4,2,3console.log(&apos;shallow copy: &apos; + arr2 ); //shallow copy: 4,2,3 浅拷贝和深拷贝的区分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先深复制和浅复制只针对像 Object, Array 这样的复杂对象的。简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是一个简单的浅复制实现 123456789101112var obj = &#123; a:1, arr: [2,3] &#125;;var shallowObj = shallowCopy(obj);function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅复制会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址,导致的结果就是： 12shallowObj.arr[1] = 5;obj.arr[1] // = 5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而深复制则不同，它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，如果对象比较大，层级也比较多，深复制会带来性能上的问题。在遇到需要采用深复制的场景时，可以考虑有没有其他替代的方案。在实际的应用场景中，也是浅复制更为常用 2、浅拷贝的实现(1).简单的引用复制1234567891011121314function shallowClone(copyObj) &#123; var obj = &#123;&#125;; for ( var i in copyObj) &#123; obj[i] = copyObj[i]; &#125; return obj;&#125;var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = shallowClone(x);console.log(y.b.f === x.b.f); // true (2).Object.assign()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象 1234567var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = Object.assign(&#123;&#125;, x);console.log(y.b.f === x.b.f); // true 3、深拷贝的实现(1)、Array的slice和concat方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。之所以把它放在深拷贝里，是因为它看起来像是深拷贝。而实际上它是浅拷贝。原数组的元素会按照下述规则拷贝 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 1234567var array = [1,2,3]; var array_shallow = array; var array_concat = array.concat(); var array_slice = array.slice(0); console.log(array === array_shallow); //true console.log(array === array_slice); //false，“看起来”像深拷贝console.log(array === array_concat); //false，“看起来”像深拷贝 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出，concat和slice返回的不同的数组实例，这与直接的引用复制是不同的。而从另一个例子可以看出Array的concat和slice并不是真正的深复制，数组中的对象元素(Object,Array等)只是复制了引用。如下： 123456789var array = [1, [1,2,3], &#123;name:&quot;array&quot;&#125;]; var array_concat = array.concat();var array_slice = array.slice(0);array_concat[1][0] = 5; //改变array_concat中数组元素的值 console.log(array[1]); //[5,2,3] console.log(array_slice[1]); //[5,2,3] array_slice[2].name = &quot;array_slice&quot;; //改变array_slice中对象元素的值 console.log(array[2].name); //array_sliceconsole.log(array_concat[2].name); //array_slice (2)、JSON对象的parse和stringify&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深拷贝。 123456789101112131415161718//例1var source = &#123; name:&quot;source&quot;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));target.name = &quot;target&quot;; //改变target的name属性console.log(source.name); //source console.log(target.name); //targettarget.child.name = &quot;target child&quot;; //改变target的child console.log(source.child.name); //child console.log(target.child.name); //target child//例2var source = &#123; name:function()&#123;console.log(1);&#125;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefined//例3var source = &#123; name:function()&#123;console.log(1);&#125;, child:new RegExp(&quot;e&quot;) &#125;var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefinedconsole.log(target.child); //Object &#123;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法使用较为简单，可以满足基本的深拷贝需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深拷贝(而且会直接丢失相应的值)。还有一点不好的地方是它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。同时如果对象中存在循环引用的情况也无法正确处理。 4、jQuery.extend()方法源码实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery的源码 - src/core.js #L121源码及分析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354jQuery.extend = jQuery.fn.extend = function() &#123; //给jQuery对象和jQuery原型对象都添加了extend扩展方法 var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false; //以上其中的变量：options是一个缓存变量，用来缓存arguments[i]，name是用来接收将要被扩展对象的key，src改变之前target对象上每个key对应的value。 //copy传入对象上每个key对应的value，copyIsArray判定copy是否为一个数组，clone深拷贝中用来临时存对象或数组的src。 // 处理深拷贝的情况 if (typeof target === &quot;boolean&quot;) &#123; deep = target; target = arguments[1] || &#123;&#125;; //跳过布尔值和目标 i++; &#125; // 控制当target不是object或者function的情况 if (typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target)) &#123; target = &#123;&#125;; &#125; // 当参数列表长度等于i的时候，扩展jQuery对象自身。 if (length === i) &#123; target = this; --i; &#125; for (; i &lt; length; i++) &#123; if ((options = arguments[i]) != null) &#123; // 扩展基础对象 for (name in options) &#123; src = target[name]; copy = options[name]; // 防止永无止境的循环，这里举个例子，如var i = &#123;&#125;;i.a = i;$.extend(true,&#123;&#125;,i);如果没有这个判断变成死循环了 if (target === copy) &#123; continue; &#125; if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) &#123; if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src: []; // 如果src存在且是数组的话就让clone副本等于src否则等于空数组。 &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src: &#123;&#125;; // 如果src存在且是对象的话就让clone副本等于src否则等于空数组。 &#125; // 递归拷贝 target[name] = jQuery.extend(deep, clone, copy); &#125; else if (copy !== undefined) &#123; target[name] = copy; // 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性。 &#125; &#125; &#125; &#125; // 返回修改的对象 return target;&#125;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery的extend方法使用基本的递归思路实现了浅拷贝和深拷贝，但是这个方法也无法处理源对象内部循环引用，例如： 12345var a = &#123;&quot;name&quot;:&quot;aaa&quot;&#125;;var b = &#123;&quot;name&quot;:&quot;bbb&quot;&#125;;a.child = b;b.parent = a;$.extend(true,&#123;&#125;,a);//直接报了栈溢出。Uncaught RangeError: Maximum call stack size exceeded 参考文章：https://github.com/wengjq/Blog/issues/3 参考文章: https://www.zhihu.com/question/23031215/answer/46220227","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":" 消息弹框 ","slug":"消息弹框","date":"2018-12-07T09:29:10.000Z","updated":"2018-12-12T15:08:38.000Z","comments":true,"path":"2018/12/07/消息弹框/","link":"","permalink":"http://yoursite.com/2018/12/07/消息弹框/","excerpt":"","text":"vue 中封装的 showTotast 和 heideLoading123456789101112131415161718192021222324252627282930313233343536.win &#123; width: 100%; height: 100%; position: fixed; top: 0; z-index: 99; text-align: center;&#125;.cue &#123; background: rgba(0, 0, 0, 0.6); color: #fff; padding: 0.14rem; margin: 65% auto; border-radius: 0.08rem; font-size: 0.14rem; display: inline-table; z-index: 99999;&#125;&lt;div class=&quot;win&quot; v-if=&quot;msg != &apos;&apos;&quot;&gt; &lt;div class=&quot;cue&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/div&gt;// showtotast 当前的 this 指向，消息内容showTotast: function(_this, msg) &#123; _this.msg = msg; setTimeout(function() &#123; _this.msg = &quot;&quot;; &#125;, 2000);&#125;,// cancelLoadinghideLoading: function(_this) &#123; setTimeout(function() &#123; _this.msg = &quot;&quot;; &#125;, 400);&#125;,","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":" ajax 请求，返回值为 304 Not Modify 错误原因与解决办法","slug":"ajax-请求，返回值为-304-Not-Modify-错误原因与解决办法","date":"2018-12-07T09:13:38.000Z","updated":"2018-12-12T15:13:10.000Z","comments":true,"path":"2018/12/07/ajax-请求，返回值为-304-Not-Modify-错误原因与解决办法/","link":"","permalink":"http://yoursite.com/2018/12/07/ajax-请求，返回值为-304-Not-Modify-错误原因与解决办法/","excerpt":"","text":"原因：因为 http 的请求缓存问题引起的，前后调用相同的两个请求，服务器比较懒，不想给你重新发送一个请求，所以就用了缓存从而产生304了解决方案：加一个时间戳1234axios.get(&quot;postData.json?&quot;) .then(res =&gt; &#123; // to do something &#125;); 那么我们加一个参数就行了，这个参数没有什么实际意义，但是可以帮助我们让每次发的请求都不一样 123456let date = new Date();let timer = date.getTime().toString();axios.get(&quot;postData.json?timer=&quot; + timer) .then(res =&gt; &#123; //to do something &#125;);","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":" js 去除空字符串、空格 ","slug":"js-去除空字符串、空格","date":"2018-12-05T08:02:53.000Z","updated":"2018-12-12T15:11:48.000Z","comments":true,"path":"2018/12/05/js-去除空字符串、空格/","link":"","permalink":"http://yoursite.com/2018/12/05/js-去除空字符串、空格/","excerpt":"","text":"使用 js 去除字符串的方法有三种： 1. 使用正则 replace 匹配 去除字符串内所有的空格：str = str.replace(/\\s*/g,””); 去除字符串内两头的空格：str = str.replace(/^\\s|\\s$/g,””); 去除字符串内左侧的空格：str = str.replace(/^\\s*/,””); 去除字符串内右侧的空格：str = str.replace(/(\\s*$)/g,””); 2. str.trim()方法trim()方法是用来删除字符串两端的空白字符并返回，trim方法并不影响原来的字符串本身，它返回的是一个新的字符串。 缺陷：只能去除字符串两端的空格，不能去除中间的空格 单独去除左侧空格则使用 str.trimLeft(); //var str_1 = str.trimLeft(); 单独去除右侧空格则使用 str.trimRight();//var str_1 = str.trimRight(); 3. JQ方法：$.trim(str)方法 $.trim() 函数用于去除字符串两端的空白字符。 注意：$.trim()函数会移除字符串开始和末尾处的所有换行符，空格(包括连续的空格)和制表符。如果这些空白字符在字符串中间时，它们将被保留，不会被移除。","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"截取url后面的参数","slug":"截取url后面的参数","date":"2018-12-04T07:44:14.000Z","updated":"2018-12-12T15:10:10.000Z","comments":true,"path":"2018/12/04/截取url后面的参数/","link":"","permalink":"http://yoursite.com/2018/12/04/截取url后面的参数/","excerpt":"","text":"JS 获取 url 传递参数，JS 获取 url? 后面的参数方法一： 正则表达式123456function getParam(name) &#123; var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125;, 方法二：123456789101112function GetRequest() &#123; var url = location.search; //获取url中&quot;?&quot;符后的字串 var theRequest = new Object(); if (url.indexOf(&quot;?&quot;) != -1) &#123; var str = url.substr(1); strs = str.split(&quot;&amp;&quot;); for (var i = 0; i &lt; strs.length; i++) &#123; theRequest[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]); &#125; &#125; return theRequest;&#125; 方法三：123456789101112131415161718192021222324252627/** * 获取指定的URL参数值 * URL:http://www.quwan.com/index?name=tyler * 参数：paramName URL参数 * 调用方法:getParam(&quot;name&quot;) * 返回值:tyler */function getParam(paramName) &#123; (paramValue = &quot;&quot;), (isFound = !1); if ( this.location.search.indexOf(&quot;?&quot;) == 0 &amp;&amp; this.location.search.indexOf(&quot;=&quot;) &gt; 1 ) &#123; (arrSource = unescape(this.location.search) .substring(1, this.location.search.length) .split(&quot;&amp;&quot;)), (i = 0); while (i &lt; arrSource.length &amp;&amp; !isFound) arrSource[i].indexOf(&quot;=&quot;) &gt; 0 &amp;&amp; arrSource[i].split(&quot;=&quot;)[0].toLowerCase() == paramName.toLowerCase() &amp;&amp; ((paramValue = arrSource[i].split(&quot;=&quot;)[1]), (isFound = !0)), i++; &#125; return paramValue == &quot;&quot; &amp;&amp; (paramValue = null), paramValue;&#125;","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"vue实现 H5 的粘贴复制功能","slug":"vue实现-H5-的粘贴复制功能","date":"2018-11-23T07:08:47.000Z","updated":"2018-12-12T15:11:18.000Z","comments":true,"path":"2018/11/23/vue实现-H5-的粘贴复制功能/","link":"","permalink":"http://yoursite.com/2018/11/23/vue实现-H5-的粘贴复制功能/","excerpt":"","text":"github上有一个开源的基于上述方法实现的插件clipboardjs。他可以实现复制，剪切，黏贴操作。具体调用如下12345678910111213141516171819202122&lt;div class=&quot;copy&quot;&gt;复制内容的&lt;/div&gt;&lt;buttonclass=&quot;btn&quot;data-clipboard-action=&quot;copy&quot;data-clipboard-target=&quot;.copy&quot;&gt;Copy&lt;/button&gt;&lt;script src=&quot;js/clipboard.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var clipboard = new ClipboardJS(&quot;.btn&quot;); clipboard.on(&quot;success&quot;, function(e) &#123; console.info(&quot;Action:&quot;, e.action); console.info(&quot;Text:&quot;, e.text); console.info(&quot;Trigger:&quot;, e.trigger); e.clearSelection(); &#125;); clipboard.on(&quot;error&quot;, function(e) &#123; console.error(&quot;Action:&quot;, e.action); console.error(&quot;Trigger:&quot;, e.trigger); &#125;);&lt;/script&gt; vue的使用npm使用例子https://www.npmjs.com/package/vue-clipboard2","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"小程序封装的登录实现用户的无感登录","slug":"小程序封装的登录实现用户的无感登录","date":"2018-11-15T16:00:55.000Z","updated":"2018-11-15T16:33:06.000Z","comments":true,"path":"2018/11/16/小程序封装的登录实现用户的无感登录/","link":"","permalink":"http://yoursite.com/2018/11/16/小程序封装的登录实现用户的无感登录/","excerpt":"","text":"在最初写小程序的时候将登录做成一个单独的页面，在用户开始的时候从登录页点击，授权进入，一套流程很舒服，后面产品需求加了登录的过期处理 &#160;&#160;&#160;&#160;1.在用户第一次授权点击登录按钮之后，后面的登录不再经过登录页面；&#160;&#160;&#160;&#160;2.在登录的时候只静默在后台进行，用户是感知不到的；&#160;&#160;&#160;&#160;3.当分享给一个新用户的时候，用户走注册登录流程页面之后仍然还是这个页面，不进行页面的跳转； 拿到这个需求的时候作为一个刚开始写小程序的菜鸟的我头都炸了，经过一系列的分析有了明确的思路 &#160;&#160;&#160;&#160;1.需要在每个页面都要一个遮罩层，然后就写了登录的模板，在每个页面中都引用；&#160;&#160;&#160;&#160;2.封装登录的方法，包含点击登录和自动登录；&#160;&#160;&#160;&#160;3.自动登录的时候需要判断登录时间是否过期，因此需要重新封装微信的存储方法，通过时间戳比较，从而刷新用户的登录状态（在判断时间戳的时候，建议前端设置的过期时间要小于后端设置的过期时间） 第二种方法：设置请求拦截，在wx.request 方法中加一个拦截器，当返回登录过期的时候，进行拦截，当一个页面中有多个数据请求的时候，需要利用promise 的方法，阻止后面的数据的请求，不然你的页面发起多少个请求就会发起多少次登录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149var app = getApp();// 设置存储时间const lifeTime = 60 * 60 * 24 * 7;/** * 入口函数 */export default function main(callback) &#123; var api_token = app.getCookie(&apos;api_token&apos;); if (api_token)&#123; typeof callback ===&apos;function&apos;?callback():&apos;&apos;; return ; &#125; var pages = getCurrentPages(); //获取加载的页面 var currentPage = pages[pages.length - 1]; //获取当前页面的对象 loginInfo(function()&#123; typeof callback === &apos;function&apos; ? callback() : &apos;&apos;; &#125;,function()&#123; wx.hideLoading() currentPage.setData(&#123; authorizationStatus:true &#125;) currentPage.bindGetUserInfo = bindGetUserInfo; currentPage.bindUserInfCallback = function()&#123; currentPage.setData(&#123; authorizationStatus: false &#125;) typeof callback === &apos;function&apos; ? callback() : &apos;&apos;; &#125; &#125;);&#125;// 通过按钮点击的的登录function bindGetUserInfo(e) &#123; var that = this; var userInfo = e.userInfo; var detail = e.detail; if (!detail.userInfo) &#123; return wx.showToast(&#123; title: &apos;您拒绝了授权，无法正常访问!&apos;, icon: &apos;none&apos; &#125;) &#125; that.bindUserInfCallback(); var userInfo = detail.userInfo; wx.login(&#123; success: res =&gt; &#123; // 发送 res.code 到后台换取 openId, sessionKey, unionId var code = res.code; var username = userInfo.nickName; var avatarUrl = userInfo.avatarUrl; var gender = userInfo.gender //性别 0：未知、1：男、2：女 var province = userInfo.province; var city = userInfo.city; var share_user_id = wx.getStorageSync(&apos;share_user_id&apos;) var country = userInfo.country; app.getAjax(app.API.login, &#123; code: code, encrypted: detail.encryptedData, share_user_id: share_user_id, iv: detail.iv &#125;, (resu) =&gt; &#123; if (resu.status) &#123; var api_token = resu.result.userInfo.api_token; var user_id = resu.result.userInfo.user_id; app.setCookie(&apos;headimg&apos;, avatarUrl,lifeTime); app.setCookie(&apos;username&apos;, username, lifeTime); app.setCookie(&apos;city&apos;, city, lifeTime); app.setCookie(&apos;gender&apos;, gender, lifeTime); app.setCookie(&quot;user_id&quot;, user_id, lifeTime); app.setCookie(&quot;api_token&quot;, api_token, lifeTime); wx.removeStorageSync(&apos;share_user_id&apos;) that.bindUserInfCallback(); &#125; else &#123; console.log(resu) wx.showToast(&#123; icon: &apos;none&apos;, title: resu, &#125;) &#125; &#125;) &#125;, fail: (err) =&gt; &#123; wx.showToast(&#123; title: err, icon: &apos;none&apos; &#125;); &#125; &#125;)&#125;// 过期自动登录function loginInfo(success,error) &#123; var that = this; wx.login(&#123; success: res =&gt; &#123; // 发送 res.code 到后台换取 openId, sessionKey, unionId var code = res.code; wx.getUserInfo(&#123; lang: &apos;zh_CN&apos;, success: function (data) &#123; console.log(data) var userInfo = data.userInfo; var username = userInfo.nickName; var avatarUrl = userInfo.avatarUrl; var gender = userInfo.gender //性别 0：未知、1：男、2：女 var province = userInfo.province; var city = userInfo.city; var country = userInfo.country; var share_user_id = wx.getStorageSync(&apos;share_user_id&apos;) app.getAjax(app.API.login, &#123; code: code, encrypted: data.encryptedData, iv: data.iv, share_user_id: share_user_id &#125;, (resu) =&gt; &#123; if (resu.status) &#123; var api_token = resu.result.userInfo.api_token; var user_id = resu.result.userInfo.user_id; app.setCookie(&apos;headimg&apos;, avatarUrl, lifeTime); app.setCookie(&apos;username&apos;, username, lifeTime); app.setCookie(&apos;city&apos;, city, lifeTime); app.setCookie(&apos;gender&apos;, gender, lifeTime); app.setCookie(&quot;user_id&quot;, user_id, lifeTime); app.setCookie(&quot;api_token&quot;, api_token, lifeTime); console.log(share_user_id) wx.removeStorageSync(&apos;share_user_id&apos;) typeof success === &apos;function&apos;? success():&apos;&apos;; &#125; else &#123; wx.showToast(&#123; icon: &apos;none&apos;, title: resu, &#125;) &#125; &#125;) &#125;, fail: (err) =&gt; &#123; typeof error ===&apos;function&apos; ? error() :&apos;&apos;; &#125; &#125;) &#125;, fail: res =&gt; &#123; wx.showToast(&#123; icon: &apos;none&apos;, title: res, &#125;) &#125; &#125;)&#125;","categories":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"js实现上拉加载兼容移动端","slug":"js实现上拉加载兼容移动端","date":"2018-11-15T15:38:08.000Z","updated":"2018-11-15T15:49:00.000Z","comments":true,"path":"2018/11/15/js实现上拉加载兼容移动端/","link":"","permalink":"http://yoursite.com/2018/11/15/js实现上拉加载兼容移动端/","excerpt":"","text":"vue中封装的简易的上拉加载js的公共方法 123456789101112131415161718192021222324252627282930313233343536_reachBottom(url,data,callback) &#123; // api 参数 回调函数 let _this = this; if (url) &#123; window.addEventListener(&quot;scroll&quot;, function() &#123; // 监听滚动条 let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop; // 兼容 ios 和 android 的滚动 if ( scrollTop + document.documentElement.clientHeight == document.body.scrollHeight ) &#123; if (_this.page &gt;= _this.pages) &#123; // 判断是否上拉加载 _this.errStaus = true; _this.errInfo = &quot;已经没有新的数据了&quot;; setTimeout(function() &#123; _this.errStaus = false; &#125;, 2000); // 弹框的自动取消 return; &#125; else if (_this.page &lt; _this.pages &amp;&amp; _this.pages != 1) &#123; load(_this); // 加载中的方法 _this.page+=1; data.page = _this.page _this._http(url, data, function(res) &#123; _this.msg = res.message; if (res.code == 200) &#123; callback.call(null, res.datas); &#125; &#125;); &#125; &#125; &#125;); &#125; else &#123; return false; &#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-遮罩阻止默认滚动事件","slug":"vue-遮罩阻止默认滚动事件","date":"2018-11-14T13:29:33.000Z","updated":"2018-11-14T13:32:56.000Z","comments":true,"path":"2018/11/14/vue-遮罩阻止默认滚动事件/","link":"","permalink":"http://yoursite.com/2018/11/14/vue-遮罩阻止默认滚动事件/","excerpt":"","text":"vue中提供 @touchmove.prevent 方法可以完美解决这个问题。1&lt;div class=&quot;child&quot; @touchmove.prevent &gt;&lt;/div&gt; vue 同时还提供了其他的修饰符1.阻止单击事件的继续传播：1&lt;a class=&quot;child&quot; v-on:click.stop=&apos;doThis&apos; &gt;&lt;/a&gt; 2.提交事件不再重载页面 ：1&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; 3.修饰符可以串联 ：1&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt; 4.只有修饰符 ：1&lt;form v-on:submit.prevent&gt;&lt;/form&gt; 5.添加事件监听器时使用事件捕获模式， 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 ：1&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt; 6.只当在 event.target 是当前元素自身时触发处理函数 ，即事件不是从内部元素触发的 ：1&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"markdown的基本语法","slug":"markdown的基本语法","date":"2018-11-10T06:33:27.000Z","updated":"2018-11-10T11:09:34.000Z","comments":true,"path":"2018/11/10/markdown的基本语法/","link":"","permalink":"http://yoursite.com/2018/11/10/markdown的基本语法/","excerpt":"","text":"1. 标题的几种写法# 一级标题 ## 二级标题 ### 三级标题 ... ####### 七级标题&#160;tips:markdown在线编辑器 2. 列表无序列表* 1=》·1 + 2=》·2 - 3=》·3 可以看到，无序列表可以用* ， + ， — 来创建，用在线编辑器看，实际上是转换成了ul&gt;li ，所以使用哪个都可以，推荐使用*吧 有序列表有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的3.区块引用用法就是在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格 比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句 &gt;搞IT太辛苦了，想换一行怎么办？”“敲一下Enter键。” 搞IT太辛苦了，想换一行怎么办？”“敲一下Enter键。” 4.分割线分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以 *** --- _ _ _5.链接支持2种链接方式：行内式和参数式，不管是哪一种，链接文字都是用 [方括号] 来标记。 [百度]（https://baidu.com）=&gt; &#160;百度","categories":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}],"tags":[]},{"title":"hexo 创建文章、标签、分类","slug":"hexo-创建文章、标签、分类","date":"2018-11-10T06:08:45.000Z","updated":"2018-11-12T14:46:46.000Z","comments":true,"path":"2018/11/10/hexo-创建文章、标签、分类/","link":"","permalink":"http://yoursite.com/2018/11/10/hexo-创建文章、标签、分类/","excerpt":"","text":"1.创建文章&#160;&#160;&#160;&#160;在hexo下创建一个新的文章 hexo new ‘文章名称’ 创建成功后悔提示你创建在文件路径，一般都在 hexo/source/_posts 下 &#160;&#160;&#160;&#160;文章的基本设置 title: 文章名字date: 2018年11月10日14:14:13comments: true #是否可以评论toc: true # 是否显示文章目录categories: ‘hexo创建文章的基本设置’ #分类tage: #标签 2.创建标签、分类&#160;&#160;&#160;&#160;创建标签页面 hexo new page tags &#160;&#160;&#160;&#160;创建分类 hexo new page categories","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"“惯性思维”","slug":"天才在左","date":"2018-11-07T16:01:58.000Z","updated":"2018-11-10T05:44:42.000Z","comments":true,"path":"2018/11/08/天才在左/","link":"","permalink":"http://yoursite.com/2018/11/08/天才在左/","excerpt":"","text":"他：“我说的不是推翻，而是能不能尝试。当然了，如果有人不喜欢，那他可以自行选择。不过我推荐这种新的生活方式，谁说就非得按照惯性生活下去了？我觉得这没有什么不可以的，为什么你不试试看呢？假设你住在一个四通八达的路口，你每天下班总是会走某一条路，那是因为你习惯了，对吧？你应该尝试一下走别的路回家。也许那条路上美女更多，也许会有飞碟飞过，也许会有更好看的街景……生活方式也一样，你应该摆脱惯性试试新的方式，不要遵从自己已经养成的习惯。习惯不见得都是好的，抽烟就不是好习惯……而且习惯下面隐藏的东西更复杂。比方说周末大家都去酒吧，有人会说那是习惯，其实为了勾女……习惯只是个借口，不是理由对吧？所以我真的觉得你有必要换一下习惯。” 眼前这位患者的逻辑思维、世界观和我完全不是一个次元的——我是说视角。他已经用了将近3 个小时表达自己的思想，并且坚定自己的信念——同时还企图说服我……总之是一种偏执的状态。 我：“刚刚你说的我可以接受，但是貌似你所要改变的根本比这个复杂，这不是一个人的事儿，牵动整个社会，甚至牵动了整个人类文明。” 他：“人类文明怎么了？很高贵？不能改变？谁说的？神说的？人说的？人说的吧？那就好办了，我还以为是神说的呢！” 我郁闷的看着他。 他：“你真的应该尝试，你不尝试怎么知道好坏呢？” 我：“听你说我已经基本算是尝试了啊？你已经说的很多了。” 他：“你为什么不进一步尝试呢？” 我：“一盘菜端上来，我犯不着全吃了才能判断出这盘菜馊了吧？” 他：“嗯……我明白的你的顾虑了……这样吧，我从基础给你讲起？” 我苦笑着点了下头。 他：“首先，你不觉得你的生活、你的周围都很奇怪吗？” 我：“怎么奇怪了？” 他：“你要上班，你得工作，你跟同事吃饭聊天打情骂俏，然后你下班，赶路约会回家或者去酒吧，要不你就打球唱歌洗澡……这些多奇怪啊？” 我：“我还是没听出哪儿奇怪来。” 他：“那好吧，我问你：你为什么那么做？” 我：“哎？？”说实话我被问得一愣。 他：“现在明白了吧？” 我：“不是很明白……我觉得那是我的生活啊。” 他一脸很崩溃的表情，我认为那应该是我才该有的表情。 他：“你没看清本质。我来顺着这根线索展开啊：你这么做，是因为大家都这么做，对吧？为什么大家都这么做呢？因为我们身处社会当中，对吧？为什么会身处社会当中呢？因为这几千年都是这样的，对吧？为什么这几千年都是这样的呢？因为从十几万年前，我们就是群居的；为什么要群居呢？因为我们的个体不够强大，所以我们聚集在一起彼此保护，也多了生存机会。一个猿人放哨，剩下的猿人采集啊，捕鱼啊什么啊的。这时候老虎来了，放哨的看见了就吼，大家听见吼都不干活了，全上树了，安全了。后来大家一起研究出了武器，什么投石啊，什么石矛啊，什么弓箭啊，于是大家一起去打猎，这时候遇到老虎不上树了，你仍石头我射箭他投长矛，胆子大没准冲上去咬一口或者踹一脚……你别笑，我在说事实。我们，人类，就是这么生活过来的，因为我们曾经很弱小，所以我们聚集在一起。现在我们还聚集在一起，就是完全的破坏行为了！好好的森林，没了，变城市了，人在这个区域是安全的，但是既然安全了为什么还要扎堆呢？因为习惯扎堆了。我觉得人类现在有那么多厉害的武器，就个体生活在自然界呗，住树林，住山谷，住的自然点儿就成了，扎什么堆啊？为什么非要跟着那么原始的惯性生活啊？就不能突破吗？住野外挺好啊，也别吃什么大餐了，自己狩猎，天天吃野味，还高级呢……” 我：“那不是破坏的更严重吗？大家都乱砍乱伐造房子，打野生动物吃……” 他：“谁说住房子了？” 我：“那住哪儿？树上？” 他：“可以啊，山洞也成啊？” 我：“遇到野兽呢？” 他：“有武器啊，槍啊什么的。” 我：“槍哪儿来了？子弹没了怎么办？” 他：“城里那些不放弃群居的人提供啊。” 我：“哦，不是所有人都撒野外放养啊？” 他：“你这个人怎么这么偏激啊，谁说全部回归自然了？这就是你刚才打断我的后果。肯定有不愿意这么生活的人，不愿意这么生活的人就接着在城里呗。因为那些愿意的、自动改变习惯的人回到野外了，减轻了依旧选择生活在城里那些人的压力了，所以，城里那些人就应该为了野外的人免费提供生存必需品，槍啊，保暖设备啊一类的。” 我：“所以就回到我们最初说的那点了？” 他：“对！就是这样，在整个人类社会号召一下，大家自动自觉开始选择，想回归的就回归，不想的继续在城市，多好啊。” 我：“那你选择怎么生活？” 他：“我先负责发起，等大家都响应了，我再决定我怎么生活。我觉得我这个号召会有很多人响应的。” 我：“你觉得这样有意思吗？选择的时候会有很多干扰因素的。” 他：“什么因素？地域？政治？那都是人类自己祸害自己的，所以我号召这个选择，改变早就该扔掉的进化惯性。那太落后了！没准我还能为人类进化做出贡献呢！”我：“怎么贡献了？” 他：“再过几十万年，野外的人肯定跟城里人不一样了，进化或者退化了，这样世界上的人类就变成两种了，没准杂交还能出第三种……”他还在滔滔不绝。我关了录音，疲惫的看着他亢奋的在那里口若悬河的描绘那个杂交的未来。一般人很难一口气说好几个小时还保持兴奋——显然他不是一般人。记得在做前期调 查的时候，他某位亲友对他的评价还是很精准的：“我觉得他有邪教教主的潜质。”","categories":[{"name":"天才在左，瘋子在右","slug":"天才在左，瘋子在右","permalink":"http://yoursite.com/categories/天才在左，瘋子在右/"}],"tags":[]},{"title":"飞禽走兽","slug":"天才在左，疯子在右","date":"2018-11-07T16:01:58.000Z","updated":"2018-11-10T05:42:50.000Z","comments":true,"path":"2018/11/08/天才在左，疯子在右/","link":"","permalink":"http://yoursite.com/2018/11/08/天才在左，疯子在右/","excerpt":"","text":"她是非常特殊的一个案例。至今我都认为不能称之为病例，因为她的情况特殊到我闻所 未闻。也许是一种返祖现象，也许是一种进化现象，我不能确定到底是什么，甚至我对这个 案例成因（可能，我不确定）的更深入了解，也是在与她接触后两年才进一步得到的。 从我推门，进来，坐下，到拿出录音笔，本子、笔，摆好抬头看着她，她都一直饶有兴 趣的在观察着我。 她是一个19 岁看上去很开朗很漂亮的女孩。感觉就透着率真，单纯。直直的长发披肩， 嘴巴惊奇的半张着，充满了好奇的看着我。容貌配合表情简直可爱的一塌糊涂。 当我按下录音键后发现她还在直勾勾的盯着我时，有点儿不好意思了。 我：“呃……你好。” 她愣了一下，回了一下神：“你好。”然后接着充满兴趣的盯着我仔细看。 我脸红了：“你……我脸上有什么东西吗？” 她似笑非笑的还是在看：“啊？什么？” 我：“我有什么没整理好或者脸上粘了什么吗？” 她似乎是定睛仔细看了下我才确定：“没啊，你脸上什么的都没有。” 我：“那你的表情……还有那么一直看着我是为什么？” 她笑出声来了：“真有意思，我头一次看蜘蛛说话哎！哈哈哈！” 我莫名其妙：“我是蜘蛛？” 她彻底回过神来了，依旧毫不掩饰自己的惊奇：“是啊。” 我：“你是说，我长得象蜘蛛吗？” 她：“不，你就是。” 我愣了下，低头翻看着有关她的说明和描述，没看到写她有痴呆症状，只说她有臆想。 她：“不好意思啊，我没恶意，只是我头一回见到蜘蛛。说实话你刚进来我吓了一跳，有 点怕，但是等你关门的时候我觉得不可怕，很卡通，那么多爪子安排的井井有条的，摆本子 的时候超级可爱！哈哈哈哈！”看她笑不是病态的，是真的忍不住了。 我：“我在你看来是蜘蛛吗？” 她：“嗯，但是没贬义，也不是我成心这么说的。其实我知道你们觉得我有病，可是我觉 得我没病。”她停了一下压住了下一轮笑声才继续：“我也是几年前才知道只有我这样的，我 一直以为大家都是这样呢。” 我：“你是什么样的？” 她：“我能把人看成动物。” 我：“每一个人？” 她：“嗯。” 我：“都是蜘蛛吗？” 她：“不，不一样。各种各样的动物。” 我：“你能讲一下都有什么动物吗？” 她：“什么动物都有。大型动物也有，小型动物也有。昆虫还真不多，蜘蛛我是头一次见， 觉得好玩儿，所以刚才没脸没皮的傻笑了半天，你别介意啊。” 面对这么漂亮可爱的女孩我怎么会介意呢，要介意也是对别人介意嘛——比方说我们院 的领导。 我：“我不介意，但是我想听你详细的说说的到底是怎么回事儿。” 现在的她终于表情平静了很多：“我知道你们都不能理解，觉得我可能有病，但是我不怕， 大不了说自己看人不是动物就没事儿了。我觉得你没恶意，那就跟你说吧：我小的时候，从 我记事儿的时候就是这样了。我看到的人，是双重的，如果我模糊着去看，看到的人就是动 物，除非我正式的看才是人。你知道什么是模糊的看吧？就是那种发呆似得看，眼前有点儿 虚影儿的感觉……” 我：“你指的是散瞳状态吧？” 她：“散瞳？可能吧，我不熟你们那些说法，反正就是模糊着看就成了。大概因为我从小 就是这样，所以没觉得怎么可怕。但是找了不少麻烦。我们小学有个老师，是个翻鼻孔的大 猩猩！哈哈哈哈， 他上课挠后脑勺的时候太逗了，他还老喜欢挠，哈哈哈！我就笑，老师就 不高兴。那时候小，也说不明白，同学问我为什么笑，我就说大猩猩挠后脑勺多逗啊，结果 同学都私下管那个老师叫大猩猩，后来老师知道了，找了我爸去学校，很尅（音kei）了我 一顿。回家的路上我跟爸爸说了，还学给他看，他也笑得前仰后合的。不过后来跟我说不许 给老师起外号，要尊敬老师……” 她连说带比划兴奋的讲了她在小学的好几件事情，边说边笑，最后我不得不打断她的自 娱自乐：“你等一下啊，我想知道你看人有没有不是其他动物的？就是人？” 她：“没有，都是动物！哈哈哈~” 我：“你能告诉我你的父母都是什么动物吗？” 她：“我妈是猫，她跟我爸闹脾气的时候后背毛都乍起来，背着耳朵，可凶了；我爸是一 种很大的鱼，我不认识，我知道什么样，海里的那种，很大，大翅膀、大嘴，没牙……不是 真的没牙啊，我爸有牙，我是说他动物的时候没牙。很大，不对，也没那么大……反正好像 是吃小鱼还是浮游生物来的一种鱼，我在《动物世界》和水族馆都见过。” 她的表情绝对不是病态的兴奋，而且不亢奋，是自然的那种表达，很坦诚。坦诚到我都 开始怀疑自己是不是听力有问题了。 我：“那你是什么动物呢？” 她：“我是鼹鼠啊！” 我：“鼹鼠？《鼹鼠的故事》里面那只？” 她：“不不不，是真的鼹鼠。眼睛很小，还老眯着，一身黄毛，短短的，鼻子湿漉漉的， 粉的，前后爪都是粉粉的，指甲都快成铲子了，这个是我最不喜欢的。” 我：“你照镜子能看见？” 她：“嗯，直接看也成。我自己看自己爪子就不能虚着看，因为我不喜欢，要是没指甲就 小粉爪就好了……”她低下头看着自己的手一脸遗憾。 我攥着笔不知道该写什么，只好接着问：“你有看人不是动物的时候吗？比如某些时刻？” 她认真的想着：“嗯……没有，还真没有……对了！有！我看照片，看电影电视都没，都 是人，我也不知道为什么。” 我觉得我有点儿费解，目前看她很正常，没有任何病态表现，既不急躁也不偏执，性格 开朗而绝对不是亢奋。但是她所说的却匪夷所思。我决定从我自己入手。 我：“你看我是什么样的蜘蛛？” 她：“我只见过你这种，等我看看啊。”说完她靠在椅背上开始“虚”着看我。 我观察了一下，她的确是放松了眼肌在散瞳。 她：“你……身上有花纹，但是都是直直的线条，像画上去的……你的爪子……不对是腿 可真长，不过没有真的大蜘蛛那种毛……你像是塑料的。” 我不知道该说什么了。 她：“嗯，你刚才低头看手里的纸的时候，我虚着看你是在织网……你眼睛真亮，大灯泡 似得，还能反光，嘴没大牙……是那种蚂蚱似得两大瓣儿……” 我觉得自己有点儿恶心就打断了她：“好了，别看了，我觉自己得很吓人了。”我低头仔 细看对她的简述。 她：“你又在织网了！” 我抬起头：“什么样的网？” 她停止了“虚着”的状态，回神仔细想着：“嗯……是先不知道从哪儿拉出一根线，然后 缠在前腿上，又拉出一根线，也缠在前腿上，很整齐的排着……” 我：“很快吗？” 她：“不，时快时慢。” 我猛然间意识到，那是我低头在整理自己的思路。 我：“你再虚着看一下，如果我织网就说出来。” 我猜她看到我的织网行为就是我在思考，我把各种可能性挨个理顺希望从中找出个解 释…… 她：“又在织了！” 我并没看资料或者写什么，只是自己在想。 我：“我大概知道你是什么情况了，你有没有看见过很奇怪的动物？” 她：“没有，都是我知道的，不过有我叫不出名字的，奇怪的……还真没有。” …… 我觉得她可能具有一种特别的感觉，比普通人强烈的多的的感觉，她看到的人类，直接 映射为某种动物。但是我需要确定，因为这太离谱了。 后面大约花了几周的时间，我先查了一些动物习性，又了解了她的父母，跟我想的有些 出入，但是总体来说差的不远。 她的“猫”妈妈是个小心谨慎的人，为人精细，但是外表给人漫不经心的感觉；她的“鱼” 爸爸是蝠鱝（魔魟），平时慢条斯理的，但是心理年龄相对年轻，啥都好奇。对于“鼹鼠”的 她，的确比较形象。看着开朗，其实是那种胆小怕事的女孩，偷偷摸摸淘个气捣个乱成，大 事儿绝对没她。基本算她性格。出于好奇，让她见了几个我的同事，她说的每一种动物的确 对同事性格抓的比较准，这让我很惊奇。 想着她的世界都是满街的老虎喜鹊狗熊兔子章鱼，我觉得多少有点儿羡慕。 最后我没办法定义她有任何精神方面的疾病，也不可能有——完全拜她开朗的性格所致。 不过我告诉她不要对谁都说这件事儿，可能会引来不必要的麻烦。但是我没告诉她我很向往 她惊人的天赋。 大约两年后一个学医的朋友告诉我一个生物器官：鼻犁器（费尔蒙嗅器，vomeronasal organ）很多动物身上都有这个器官。那是一个特殊的感知器官，动物可以通过鼻犁器收集飘 散在空气中的残留化学物质，从而判断对方的性别、威胁与否，甚至可以用来猎物追踪、预 知地震。这就是人们常说很多动物拥有的“第六感”。人类虽然还存在这个器官，但都已经高 度退化。我当时立刻想到了她的自我描述：鼹鼠——嗅觉远远强于视觉。也许她的鼻犁器特 别发达吧？当然那是我瞎猜的。不过，说句无责任的感慨：有时候眼睛看到的，还真不一定 就是真实的。","categories":[{"name":"天才在左，瘋子在右","slug":"天才在左，瘋子在右","permalink":"http://yoursite.com/categories/天才在左，瘋子在右/"}],"tags":[{"name":"書籍","slug":"書籍","permalink":"http://yoursite.com/tags/書籍/"}]}]}